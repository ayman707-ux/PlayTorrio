<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ayman's PlayTorrio</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<!-- Video.js CSS -->
<link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
<style>
        :root {
            /* Purple theme */
            --primary: #2a1847;    /* header/cards */
            --secondary: #8b5cf6;  /* subtle accents */
            --tertiary: #c084fc;   /* highlights/pills */
            --dark: #120a1f;       /* page background */
            --light: #f8f9fa;      /* text */
            --gray: #6c757d;       /* muted text */
            --danger: #dc3545;
            --success: #28a745;
            /* Accent (kept var name for minimal changes) */
            --vlc-orange: #a855f7; /* accent purple */
            --vlc-dark: #2d2d2d;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--dark);
            color: var(--light);
            overflow-x: hidden;
        }
        
        header {
            background-color: var(--primary);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--light);
            text-decoration: none;
        }
        
        .logo span {
            color: var(--vlc-orange);
        }
        
        .search-container {
            flex: 1;
            max-width: 600px;
            margin: 0 2rem;
            position: relative;
        }
        
        .search-container input {
            width: 100%;
            padding: 0.8rem 1.2rem;
            padding-left: 3rem;
            border-radius: 30px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .search-container input:focus {
            outline: none;
            background-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.3);
        }
        
        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
        }
        
        .user-actions {
            display: flex;
            gap: 1rem;
        }
        
        .btn {
            padding: 0.6rem 1.2rem;
            border-radius: 30px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--vlc-orange);
            color: var(--vlc-orange);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary:hover {
            background-color: #9333ea;
        }
        
        .btn-outline:hover {
            background-color: rgba(168, 85, 247, 0.1);
        }
        
        .btn-outline.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-left: 1rem;
            border-left: 4px solid var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .section-title i {
            color: var(--tertiary);
        }
        
        .categories {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            padding: 0.5rem 0;
        }
        
        .category {
            padding: 0.8rem 1.5rem;
            background-color: rgba(255, 255, 255, 0.08);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
        }
        
        .category:hover, .category.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .movies-grid, .genre-grid, .genre-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .movie-card, .genre-card {
            background-color: var(--primary);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            cursor: pointer;
        }
        
        .movie-card:hover, .genre-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 12px 16px rgba(0, 0, 0, 0.3);
        }
        
        .movie-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
        }
        
        .movie-info, .genre-info {
            padding: 1rem;
        }
        
        .movie-title, .genre-title {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .movie-year {
            color: var(--tertiary);
            font-size: 0.9rem;
        }
        
        .movie-rating {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.6rem;
            border-radius: 30px;
            font-weight: 700;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .add-to-list-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn:hover {
            background-color: var(--success);
            transform: scale(1.1);
        }
        
        .add-to-list-btn.in-list {
            background-color: var(--success);
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        .done-watching-btn {
            position: absolute;
            top: 10px;
            left: 55px; /* Position next to the add-to-list button */
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .done-watching-btn:hover {
            background-color: #17a2b8; /* info blue color */
            transform: scale(1.1);
        }
        
        .done-watching-btn.is-done {
            background-color: #17a2b8;
            opacity: 1;
            transform: scale(1);
        }
        
        .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .loading i {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideInRight {
            0% { 
                transform: translateX(100%);
                opacity: 0;
            }
            100% { 
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Ensure resume modal is above all other overlays */
        #resumeModal { z-index: 6000; }
        
        .modal-content {
            background-color: var(--primary);
            border-radius: 10px;
            overflow: hidden;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-header {
            position: relative;
            height: 400px;
            overflow: hidden;
        }
        
        .modal-backdrop {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(0.4);
        }
        
        .modal-header-content {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            gap: 2rem;
        }
        
        .modal-poster {
            width: 200px;
            height: 300px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .modal-info {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        
        .modal-rating {
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.8rem;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .modal-year {
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .modal-tagline {
            font-style: italic;
            margin-bottom: 1rem;
            color: var(--tertiary);
        }
        
        .modal-body {
            padding: 2rem;
        }
        
        .modal-section-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .modal-overview {
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .cast-card {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .cast-card:hover {
            transform: translateY(-5px);
        }
        
        .cast-img {
            width: 100%;
            height: 160px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 0.5rem;
        }
        
        .cast-name {
            font-weight: 600;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
        }
        
        .cast-character {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .similar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .seasons-container {
            margin-bottom: 2rem;
        }
        
        .season-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .season-btn {
            padding: 0.5rem 1rem;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 30px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .season-btn.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .episode-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .episode-card:hover {
            border-color: var(--secondary);
        }

        .episode-card.selected {
            border-color: var(--vlc-orange);
            background-color: rgba(255, 105, 0, 0.1);
        }
        
        .episode-img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }
        
        .episode-info {
            padding: 0.8rem;
        }
        
        .episode-title {
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }
        
        .episode-date {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .torrents-container {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .torrents-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .torrents-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .torrent-item {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .torrent-info {
            flex: 1;
        }
        
        .torrent-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .torrent-details {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        .torrent-quality {
            background-color: var(--tertiary);
            color: var(--dark);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .torrent-actions {
            display: flex;
            gap: 0.5rem;
        }

        .torrent-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }

        .torrent-pagination button {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .torrent-pagination button:disabled {
            color: var(--gray);
            cursor: not-allowed;
        }

        .torrent-pagination span {
            margin: 0 1rem;
        }
        
        .torrent-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-play {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-copy {
            background-color: var(--secondary);
            color: white;
        }

        .btn-play-now {
            background-color: var(--success);
            color: white;
        }

        /* API Key Setup Modal */
        .api-setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .api-setup-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .api-setup-content {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            border-radius: 15px;
            padding: 3rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
        }
        
        .api-setup-title {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .api-setup-description {
            color: var(--light);
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .api-input-group {
            margin-bottom: 2rem;
        }
        
        .api-input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--tertiary);
            font-weight: 600;
        }
        
        .api-input {
            width: 100%;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .api-input:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        .api-setup-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .api-btn {
            padding: 1rem 2rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }
        
        .api-btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .api-btn-primary:hover {
            background-color: #e55a00;
            transform: translateY(-2px);
        }

        /* Debrid provider select styling */
        #debridProvider {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-width: 240px;
            max-width: 320px;
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 10px;
            padding: 0.55rem 2.25rem 0.55rem 0.85rem;
            color: #e9ecef;
            font-weight: 600;
            letter-spacing: 0.2px;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M5 7l5 6 5-6' stroke='%23cfd4da' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.6rem center;
            background-size: 12px;
        }
        #debridProvider:hover {
            border-color: rgba(255,255,255,0.28);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
        }
        #debridProvider:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 2px rgba(255,117,24,0.25);
        }
        /* Attempt to style dropdown menu items (supported in Chromium) */
        #debridProvider option {
            background-color: #151a20;
            color: #e9ecef;
        }
        
        .api-btn-secondary {
            background-color: transparent;
            color: var(--gray);
            border: 2px solid var(--gray);
        }
        
        .api-btn-secondary:hover {
            color: var(--light);
            border-color: var(--light);
        }

        /* Donate Modal */
        .donate-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 5500;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .donate-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .donate-content {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            border-radius: 15px;
            padding: 3rem;
            max-width: 520px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(168, 85, 247, 0.3);
            border: 2px solid var(--vlc-orange);
            position: relative;
        }
        
        .donate-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .donate-close.visible {
            display: flex;
        }
        
        .donate-close:hover {
            background-color: var(--danger);
            transform: rotate(90deg);
        }
        
        .donate-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }
        
        .donate-message {
            color: var(--light);
            margin-bottom: 2rem;
            line-height: 1.8;
            text-align: left;
        }
        
        .donate-btn {
            padding: 1rem 2.5rem;
            border-radius: 30px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            background: linear-gradient(135deg, var(--vlc-orange), #9333ea);
            color: white;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }
        
        .donate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(168, 85, 247, 0.6);
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .settings-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .settings-content {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            border-radius: 15px;
            padding: 2rem;
            max-width: 800px;
            width: min(92%, 800px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
            max-height: 85vh;
            overflow: auto;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        
        .settings-title {
            font-size: 1.8rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .settings-close {
            background: transparent;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
            padding: 0.5rem;
        }
        
        .settings-close:hover {
            color: var(--light);
        }
        
        .settings-section {
            margin-bottom: 2rem;
        }
        
        .settings-section h3 {
            color: var(--tertiary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        .source-badge { display:inline-block; padding:2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight:700; margin-left: 8px; background: #6c757d; color: #fff; }
        .source-badge.debrid { background:#198754; }
        .source-badge.webtorrent { background:#0d6efd; }
        
        .current-api-key {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            color: var(--gray);
            font-family: monospace;
        }
        
        .settings-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* VLC Player Styles */
        .vlc-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--vlc-dark);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            /* Prevent any child from increasing the viewport height */
            overflow: hidden;
        }
        
        .vlc-player-container.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .vlc-player-header {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--vlc-orange);
        }
        
        .vlc-player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
        }
        
        .vlc-player-close {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
        }
        
        .vlc-player-close:hover {
            background: #e55a00;
        }
        
        .vlc-player-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--vlc-dark);
            /* Allow inner flex children to shrink within viewport */
            min-height: 0;
            min-width: 0;
        }
        
        .file-selector {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            border-bottom: 1px solid #444;
        }
        
        .file-selector h3 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .file-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }

        /* MPV controls layout and spacing */
        #mpvControls {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 0 1.25rem;
        }

        #mpvControls .vlc-btn { width: auto; }
        
        .file-item {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .file-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }
        
        .file-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9rem;
        }

        .file-name-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark);
            color: var(--light);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            white-space: normal;
            width: max-content;
            max-width: 300px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .file-size {
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .vlc-player-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            /* Ensure contained media never pushes layout */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }
        
        .vlc-loading {
            color: var(--vlc-orange);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .vlc-loading i {
            animation: spin 1s linear infinite;
        }
        
        /* Base button styles for MPV/WCJS action buttons */
        .vlc-btn {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            transition: transform 0.25s ease, opacity 0.25s ease;
            z-index: 3;
        }
        
        .vlc-btn:hover {
            background: #e55a00;
            transform: translateY(-2px);
        }
        
        .vlc-btn.secondary {
            background: var(--secondary);
        }
        
        .vlc-btn.secondary:hover {
            background: #0199c7;
        }
        
        .subtitle-controls {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            flex-direction: column;
        }
        
        .subtitle-controls h4 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
        }
        
        .subtitle-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 1rem; /* For scrollbar */
        }
        
        .subtitle-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }
        
        .subtitle-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }

        .subtitle-item.selected {
            border-color: var(--success);
            background-color: rgba(40, 167, 69, 0.2);
        }
        
        .subtitle-lang {
            font-weight: 600;
            color: white;
            flex-grow: 1;
        }

        /* Custom Video Player Styles */
        .custom-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            /* Lock overlay to viewport */
            overflow: hidden;
        }

        .custom-player-container.active {
            opacity: 1;
            pointer-events: all;
        }

        .player-header {
            background: none;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 5;
        }

        .player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .subtitle-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .subtitle-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .upload-btn {
            background: var(--secondary);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .upload-btn:hover {
            background: #0199c7;
            transform: translateY(-1px);
        }

        .close-player-btn {
            background: var(--danger);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .close-player-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .video-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Critical for flex children so they don't overflow the viewport */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .custom-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Always fit inside container */
            /* Ensure the video stays beneath overlays */
            z-index: 1;
        }
        
        /* Video.js subtitle positioning and styling */
        .video-js .vjs-text-track-display {
            bottom: 8em !important;
            pointer-events: none;
        }
        
        .video-js .vjs-text-track-cue {
            pointer-events: auto;
        }
        
        /* Hide Video.js error messages */
        .video-js .vjs-error-display,
        .video-js .vjs-modal-dialog {
            display: none !important;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            /* Always visible to avoid being pushed off-screen */
            transform: translateY(0);
            transition: transform 0.3s ease;
            z-index: 2;
        }

        /* Auto-hide behavior scoped to custom player only */
        .custom-player-container .video-controls { transform: translateY(100%); opacity: 0; pointer-events: none; }
        .custom-player-container .video-container.show-controls .video-controls,
        .custom-player-container .video-controls.force-visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .progress-container {
            margin-bottom: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-filled {
            height: 100%;
            background: var(--vlc-orange);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .progress-time {
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .control-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        .control-left,
        .control-right { display:flex; align-items:center; gap:1rem; }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.8rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            width: 50px;
            height: 50px;
        }

        .control-btn:hover {
            background: var(--vlc-orange);
            transform: scale(1.1);
        }

        .control-btn.play-pause {
            background: var(--vlc-orange);
            font-size: 1.5rem;
            width: 60px;
            height: 60px;
        }

        .control-btn.play-pause:hover {
            background: #e55a00;
        }

        .fullscreen-btn {
            position: absolute;
            right: 1rem;
            bottom: 1rem;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--vlc-orange);
            font-size: 1.5rem;
            z-index: 2; /* below controls, above video */
        }

        .subtitle-display {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 500;
            text-align: center;
            max-width: 80%;
            display: none;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--vlc-orange);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-weight: 600;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 3000;
        }

        /* Subtitles menu panel */
        .subs-panel {
            position: absolute;
            right: 1rem;
            bottom: 6rem;
            width: 340px;
            max-height: 40vh;
            overflow: auto;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.5rem;
            display: none;
            z-index: 10;
        }
        .subs-item { display:flex; align-items:center; justify-content:space-between; background: rgba(255,255,255,0.06); color:#fff; padding:0.5rem 0.6rem; border-radius:6px; margin:0.35rem 0; cursor:pointer; }
        .subs-item:hover { background: rgba(168,85,247,0.25); }
        .subs-badge { font-size: 0.75rem; color:#ccc; }
        .subs-source { font-size: 0.75rem; opacity: 0.8; margin-left: 0.4rem; }
        .row-spread { display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
        .subs-header { display:flex; align-items:center; justify-content:space-between; color:#fff; margin-bottom:0.25rem; }
        .subs-help { color:#bbb; font-size:0.8rem; margin-bottom:0.25rem; }
        .menu-actions { display:flex; align-items:center; gap:0.5rem; }
        .menu-refresh { background: rgba(255,255,255,0.15); border:none; color:#fff; padding:0.2rem 0.5rem; border-radius:4px; cursor:pointer; }
        
        /* Subtitle Upload and Customization Styles */
        .subs-upload { display:flex; flex-direction:column; gap:0.4rem; margin:0.5rem 0; background: rgba(255,255,255,0.06); padding:0.5rem; border-radius:6px; }
        .subs-upload-btn { background: var(--vlc-orange); color:#fff; border:none; padding:0.45rem 0.75rem; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; justify-content:center; font-size:0.85rem; }
        .subs-upload-btn:hover { background:#e55a00; }
        .subs-divider { height:1px; background: rgba(255,255,255,0.12); margin:0.6rem 0; }
        .subs-settings { display:flex; flex-direction:column; gap:0.5rem; margin:0.5rem 0; }
        .subs-setting-row { display:flex; align-items:center; gap:0.5rem; font-size:0.8rem; color:#eee; }
        .subs-setting-row label { flex: 0 0 85px; }
        .subs-setting-row input[type="range"] { flex:1; }
        .subs-setting-row input[type="color"] { width:42px; height:28px; border:none; padding:0; background:none; cursor:pointer; }
        .subs-setting-row select { 
            flex:1; 
            padding:0.4rem 0.6rem; 
            border-radius:6px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.08); 
            color:#fff; 
            font-size:0.85rem;
            font-weight:500;
            cursor:pointer;
        }
        .subs-setting-row select option {
            background: #1a1a1a;
            color: #fff;
        }
        .subs-setting-value { min-width:46px; text-align:right; color:#bbb; font-size:0.75rem; }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .error-message {
            background-color: var(--danger);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Genres pages styles */
        .genre-card {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 120px;
            text-align: center;
        }
        .genre-title {
            color: var(--light);
            font-size: 1.2rem;
        }
        .genre-chip {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.1);
            color: var(--tertiary);
            border: 1px solid rgba(255,255,255,0.15);
        }
        .genre-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .genre-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .toggle-btn {
            padding: 0.5rem 1rem;
            border-radius: 30px;
            border: 2px solid var(--vlc-orange);
            background: transparent;
            color: var(--vlc-orange);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .toggle-btn.active {
            background: var(--vlc-orange);
            color: #fff;
        }
        
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .search-container {
                margin: 1rem 0;
                width: 100%;
            }
            
            .modal-header-content {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .modal-poster {
                width: 150px;
                height: 225px;
            }
            
            .modal-title {
                font-size: 1.8rem;
            }
            
            .file-list {
                grid-template-columns: 1fr;
            }
            
            .video-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .vlc-btn { /* mobile sizing override only */
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .player-header {
                z-index: 3;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .player-actions {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .control-buttons {
                gap: 0.5rem;
            }

            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }

            .control-btn.play-pause {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .api-setup-content {
                padding: 2rem;
            }

            .api-setup-buttons {
                flex-direction: column;
            }

            .settings-content {
                padding: 1.5rem;
            }

            .settings-buttons {
                flex-direction: column;
            }
        }

        /* ========================================
           NEW UI STYLES - Modern App Interface
           ======================================== */
        
        /* OLD UI: Show app-container but without flex layout, hide sidebar */
        body.ui-old {
            display: block;
            height: auto;
            overflow: visible;
        }
        
        body.ui-old .app-container {
            display: block;
            height: auto;
        }
        
        body.ui-old .app-sidebar {
            display: none !important;
        }
        
        body.ui-old .app-main {
            display: block;
            overflow: visible;
            height: auto;
        }
        
        body.ui-old header {
            position: sticky;
            top: 0;
        }
        
        body.ui-old main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
            overflow: visible;
        }
        
        /* NEW UI: Sidebar Navigation */
        body.ui-new {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        body.ui-new .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        body.ui-new .app-sidebar {
            display: flex;
            width: 240px;
            background: linear-gradient(180deg, var(--primary) 0%, #1a0d2e 100%);
            border-right: 1px solid rgba(168, 85, 247, 0.2);
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        body.ui-new .sidebar-logo {
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        body.ui-new .sidebar-logo:hover {
            background: rgba(168, 85, 247, 0.1);
        }
        
        body.ui-new .sidebar-logo i {
            color: var(--vlc-orange);
            font-size: 1.8rem;
        }
        
        /* Sidebar Stats Panel */
        body.ui-new .sidebar-stats {
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        body.ui-new .stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        body.ui-new .stat-item i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
            width: 32px;
            text-align: center;
        }
        
        body.ui-new .stat-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        body.ui-new .stat-label {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        body.ui-new .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--light);
        }
        
        body.ui-new .sidebar-divider {
            height: 1px;
            background: rgba(168, 85, 247, 0.15);
            margin: 0.5rem 1rem;
        }
        
        body.ui-new .nav-section-title {
            padding: 1rem 1.5rem 0.5rem;
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
        }
        
        body.ui-new .nav-badge {
            margin-left: auto;
            padding: 0.15rem 0.5rem;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
        }
        
        /* Sidebar Quick Actions */
        body.ui-new .sidebar-quick-actions {
            padding: 0.75rem 1.5rem;
            margin-top: auto;
        }
        
        body.ui-new .quick-action-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }
        
        body.ui-new .quick-action-btn {
            width: 100%;
            padding: 0.65rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        body.ui-new .quick-action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-1px);
        }
        
        body.ui-new .sidebar-user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        body.ui-new .sidebar-user-info i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
        }
        
        body.ui-new .sidebar-nav {
            flex: 1;
            padding: 0.5rem 0;
        }
        
        body.ui-new .nav-item {
            padding: 0.85rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            font-weight: 500;
        }
        
        body.ui-new .nav-item:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item.active {
            background: rgba(168, 85, 247, 0.15);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item i {
            width: 20px;
            text-align: center;
        }
        
        body.ui-new .sidebar-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        /* Main Content Area */
        body.ui-new .app-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--dark);
        }
        
        /* Modern Header */
        body.ui-new header {
            position: static;
            background: linear-gradient(90deg, var(--primary) 0%, #1f1035 100%);
            padding: 1.25rem 2rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new .header-container {
            justify-content: space-between;
            max-width: none;
        }
        
        body.ui-new .logo {
            display: none; /* Logo in sidebar instead */
        }
        
        body.ui-new .search-container {
            flex: 0 1 500px;
            margin: 0;
        }
        
        body.ui-new .search-container input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .search-container input:focus {
            background: rgba(0, 0, 0, 0.4);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .user-actions {
            gap: 0.75rem;
        }
        
        body.ui-new .btn {
            border-radius: 8px;
            padding: 0.65rem 1.1rem;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .btn-outline {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-outline.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            color: white;
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-primary {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }
        
        /* Connection Status */
        body.ui-new .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.3);
            border-radius: 20px;
            font-size: 0.85rem;
            color: #28a745;
        }
        
        body.ui-new .connection-status i {
            font-size: 0.5rem;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* Hide connection status in OLD UI */
        body.ui-old .connection-status {
            display: none;
        }
        
        /* Enhanced Page Header */
        body.ui-new .page-header-enhanced {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .page-title-section {
            flex: 1;
        }
        
        body.ui-new .page-subtitle {
            margin-top: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }
        
        body.ui-new .page-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        body.ui-new .action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 1.25rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        
        body.ui-new .action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-2px);
        }
        
        /* Hide enhanced elements in OLD UI */
        body.ui-old .page-header-enhanced {
            display: none;
        }
        
        body.ui-old .page-subtitle {
            display: none;
        }
        
        /* Content Area */
        body.ui-new main {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 0;
            padding: 2rem 2.5rem;
            max-width: none;
            background: linear-gradient(135deg, var(--dark) 0%, #0a0612 100%);
        }
        
        /* Modern Section Titles */
        body.ui-new .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.3);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        body.ui-new .section-title i {
            color: var(--vlc-orange);
        }
        
        /* Category Pills */
        body.ui-new .categories {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        body.ui-new .category {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.5rem;
            border-radius: 25px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.25s ease;
            font-weight: 500;
        }
        
        body.ui-new .category i {
            font-size: 0.9rem;
        }
        
        body.ui-new .category:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.2);
        }
        
        body.ui-new .category.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }
        
        /* Modern Movie Cards with Glass Morphism */
        body.ui-new .movie-card {
            background: rgba(42, 24, 71, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        body.ui-new .movie-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.35);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .movie-poster {
            position: relative;
            overflow: hidden;
        }
        
        body.ui-new .movie-poster::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        body.ui-new .movie-card:hover .movie-poster::after {
            opacity: 1;
        }
        
        body.ui-new .movie-poster img {
            transition: transform 0.3s ease;
        }
        
        body.ui-new .movie-card:hover .movie-poster img {
            transform: scale(1.1);
        }
        
        /* New UI Add to List Button */
        body.ui-new .add-to-list-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .add-to-list-btn:hover {
            background: var(--success);
            border-color: var(--success);
            transform: scale(1.1) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        
        body.ui-new .add-to-list-btn.in-list {
            background: var(--success);
            border-color: var(--success);
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        body.ui-new .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        /* New UI Done Watching Button */
        body.ui-new .done-watching-btn {
            position: absolute;
            top: 12px;
            left: 60px; /* Position next to the add-to-list button */
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(23, 162, 184, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .done-watching-btn:hover {
            background: #17a2b8;
            border-color: #17a2b8;
            transform: scale(1.1) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.4);
        }
        
        body.ui-new .done-watching-btn.is-done {
            background: #17a2b8;
            border-color: #17a2b8;
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
        }
        
        body.ui-new .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        body.ui-new .movie-info {
            padding: 1.25rem;
            background: linear-gradient(180deg, rgba(42, 24, 71, 0.6) 0%, rgba(18, 10, 31, 0.8) 100%);
        }
        
        body.ui-new .movie-title {
            font-size: 1.05rem;
            margin-bottom: 0.5rem;
            color: var(--light);
        }
        
        body.ui-new .movie-meta {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        body.ui-new .movie-rating {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
            border: 1px solid rgba(255, 193, 7, 0.4);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .movie-year {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
        }
        
        /* Genre Boxes */
        body.ui-new .genre-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            transition: all 0.3s ease;
        }
        
        body.ui-new .genre-box:hover {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.25) 0%, rgba(139, 92, 246, 0.2) 100%);
            border-color: var(--vlc-orange);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(168, 85, 247, 0.3);
        }
        
        /* Modern Modal */
        body.ui-new .modal-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        body.ui-new .modal-close {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        body.ui-new .modal-close:hover {
            background: rgba(220, 53, 69, 0.3);
            border-color: #dc3545;
            transform: rotate(90deg);
        }
        
        /* Buttons in Modal */
        body.ui-new .play-btn {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border: none;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .play-btn:hover {
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
            transform: translateY(-2px);
        }
        
        /* Settings Modal */
        body.ui-new .settings-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
        }
        
        body.ui-new .settings-section {
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* Loading Indicators */
        body.ui-new .loading {
            color: var(--vlc-orange);
        }
        
        /* Scrollbar Styling for New UI */
        body.ui-new ::-webkit-scrollbar {
            width: 10px;
        }
        
        body.ui-new ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 5px;
        }
        
        body.ui-new ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #9333ea 0%, var(--vlc-orange) 100%);
        }
        
        /* Responsive adjustments for New UI */
        @media (max-width: 1024px) {
            body.ui-new .app-sidebar {
                width: 200px;
            }
            
            body.ui-new main {
                padding: 1.5rem 1.5rem;
            }
        }
        
        @media (max-width: 768px) {
            body.ui-new .app-sidebar {
                position: fixed;
                left: -240px;
                top: 0;
                bottom: 0;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            
            body.ui-new .app-sidebar.mobile-open {
                left: 0;
            }
            
            body.ui-new .search-container {
                flex: 1;
            }
        }
    </style>
</head>
<body>
<!-- API Setup Modal -->
<div class="api-setup-modal" id="apiSetupModal">
    <div class="api-setup-content">
        <h2 class="api-setup-title">
            <i class="fas fa-key"></i>
            Setup Required
        </h2>
        <p class="api-setup-description">
            Welcome to PlayTorrio Streamer! To search for torrents, you need to provide your Jackett API key.
            Please install Jackett, add the indexers you'd like to search torrents from, and paste the API key below.
            You can download the installer by clicking
            <button type="button" id="openJackettLink" style="background:#0d6efd;color:#fff;border:none;border-radius:6px;padding:0.25rem 0.6rem;cursor:pointer;font-weight:600;">Here</button>.
            This will be saved locally and used to access your Jackett server.
        </p>
        <div class="api-input-group">
            <label for="firstTimeApiKey">Jackett API Key:</label>
            <input type="text" id="firstTimeApiKey" class="api-input" placeholder="Enter your Jackett API key..." />
        </div>
        <div class="api-setup-buttons">
            <button class="api-btn api-btn-primary" id="saveFirstTimeApiKey">
                <i class="fas fa-save"></i>
                Save & Continue
            </button>
            <button class="api-btn api-btn-secondary" id="useTorrentlessSetup">
                <i class="fas fa-play"></i>
                Watch without Jackett
            </button>
            <button class="api-btn" id="videoTutorialFirst" style="background:#0d6efd; color:#fff;">
                <i class="fas fa-video"></i> Video Tutorial
            </button>
        </div>
    </div>
</div>

<!-- Donate Modal -->
<div class="donate-modal" id="donateModal">
    <div class="donate-content">
        <button class="donate-close" id="donateClose">
            <i class="fas fa-times"></i>
        </button>
        <h2 class="donate-title">
            <i class="fas fa-heart"></i>
            Support the Developer
        </h2>
        <div class="donate-message">
            <p>Hi there! I built this app completely on my own — it's been over half a year of late nights, debugging, and learning just to make something people can enjoy. If you've found it useful, a small donation would mean the world to me. It helps keep the project alive and motivates me to keep improving it.</p>
            <p style="margin-top: 1rem;">Thank you for even considering it ❤️</p>
        </div>
        <button class="donate-btn" id="donateButton">
            <i class="fas fa-heart"></i>
            Donate
        </button>
    </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
    <div class="settings-content">
        <div class="settings-header">
            <h2 class="settings-title">
                <i class="fas fa-cog"></i>
                Settings
            </h2>
            <button class="settings-close" id="settingsClose">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="settings-section">
            <h3>Jackett API Configuration</h3>
            <div class="current-api-key" id="currentApiKey">
                No API key configured
            </div>
            <div class="api-input-group">
                <label for="newApiKey">New API Key:</label>
                <input type="text" id="newApiKey" class="api-input" placeholder="Enter new Jackett API key..." />
            </div>
            <div style="margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useTorrentlessToggle" />
                    <span>Watch without Jackett (use built-in sources)</span>
                </label>
                <div style="margin-top:0.5rem; color:#ffc107; font-size:0.9rem;">
                    Warning: may result in fewer sources and slower buffering.
                </div>
                <div style="margin-top:0.75rem;">
                    <button class="api-btn" id="videoTutorialBtn" style="background:#0d6efd; color:#fff;">
                        <i class="fas fa-video"></i> Video Tutorial
                    </button>
                </div>
            </div>
        </div>

        <div class="settings-section" id="debridSection" style="margin-top:1.25rem;">
            <h3>Debrid (Cloud Cache) </h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05); display:flex; flex-direction: column; gap:0.75rem;">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useDebridToggle" />
                    <span>Use Debrid</span>
                </label>
                <div style="display:flex; gap:0.75rem; align-items:center; flex-wrap: wrap;">
                    <label for="debridProvider">Provider:</label>
                    <select id="debridProvider" class="api-input" style="min-width:220px; max-width:260px;">
                        <option value="realdebrid">Real‑Debrid</option>
                        <option value="alldebrid">AllDebrid</option>
                        <option value="torbox">TorBox</option>
                        <option value="premiumize">Premiumize</option>
                    </select>
                    <span id="debridStatus" style="font-size:0.9rem; opacity:0.85;">Not logged in</span>
                </div>
                <div class="api-input-group" id="rdClientIdGroup">
                    <label for="rdClientId">Real‑Debrid Client ID (device flow):</label>
                    <input type="text" id="rdClientId" class="api-input" placeholder="Enter your RD Client ID (e.g., XXXXXXXXXXXXX)" />
                </div>
                <div id="rdButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items:center;">
                    <button class="api-btn" id="rdDeviceLogin" style="background:#198754; color:#fff;">
                        <i class="fas fa-sign-in-alt"></i> Login with Real‑Debrid
                    </button>
                    <small style="opacity:0.85;">No password needed. Authenticate on real‑debrid.com using a short code.</small>
                </div>
                <div id="rdCodePanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                        <div>Code:</div>
                        <div id="rdUserCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                        <button class="api-btn" id="rdCopyCode" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                    <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                        <div>Verify at:</div>
                        <a id="rdVerifyUrl" href="#" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://real-debrid.com/device</a>
                        <button class="api-btn" id="rdOpenVerify" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                        <span id="rdLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting for approval…</span>
                        <button class="api-btn api-btn-secondary" id="rdCancelLogin"><i class="fas fa-times"></i> Cancel</button>
                    </div>
                </div>
                <div class="api-input-group" id="rdTokenGroup">
                    <label for="debridToken">Real‑Debrid Token (temporary MVP):</label>
                    <input type="password" id="debridToken" class="api-input" placeholder="Paste RD token..." />
                </div>
                <div id="rdTokenButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                    <button class="api-btn" id="saveDebridToken" style="background:#0d6efd; color:#fff;">
                        <i class="fas fa-key"></i> Save Token
                    </button>
                    <button class="api-btn api-btn-secondary" id="clearDebridToken">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                </div>
                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Your token is stored locally and never exposed to websites.</div>

                <!-- AllDebrid PIN Login UI -->
                <div id="adSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                        <button class="api-btn" id="adStartPin" style="background:#198754; color:#fff;"><i class="fas fa-sign-in-alt"></i> Login with AllDebrid (PIN)</button>
                        <small style="opacity:0.85;">Authenticate on alldebrid.com/pin with the code shown.</small>
                    </div>
                    <div id="adPinPanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                        <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                            <div>PIN:</div>
                            <div id="adPinCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                            <button class="api-btn" id="adCopyPin" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                        </div>
                        <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                            <div>Open:</div>
                            <a id="adUserUrl" href="https://alldebrid.com/pin/" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://alldebrid.com/pin/</a>
                            <button class="api-btn" id="adOpenUserUrl" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                            <span id="adLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting…</span>
                            <button class="api-btn api-btn-secondary" id="adCancelPin"><i class="fas fa-times"></i> Cancel</button>
                        </div>
                    </div>
                    <div class="api-input-group" style="margin-top:0.75rem;">
                        <label for="adApiKey">AllDebrid API Key (optional/manual):</label>
                        <input type="password" id="adApiKey" class="api-input" placeholder="Paste AD API key..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="adSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                        <button class="api-btn api-btn-secondary" id="adClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                </div>

                <!-- TorBox Auth (token) -->
                <div id="tbSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div class="api-input-group">
                        <label for="tbToken">TorBox Token (temporary):</label>
                        <input type="password" id="tbToken" class="api-input" placeholder="Paste TorBox token..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="tbSaveToken" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save Token</button>
                        <button class="api-btn api-btn-secondary" id="tbClearToken"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                    <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Token stored locally.</div>
                </div>

                <!-- Premiumize Auth (API Key) -->
                <div id="pmSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div class="api-input-group">
                        <label for="pmApiKey">Premiumize API Key:</label>
                        <input type="password" id="pmApiKey" class="api-input" placeholder="Enter your Premiumize API key..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="pmSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                        <button class="api-btn api-btn-secondary" id="pmClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                    <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">
                        Get your API key from <a href="https://www.premiumize.me/account" target="_blank" style="color:#0d6efd; text-decoration:underline;">premiumize.me/account</a>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>User Interface</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <!-- Fullscreen toggle (first option) -->
                <div style="margin-bottom:1rem; padding-bottom:0.75rem; border-bottom:1px solid rgba(255,255,255,0.1);">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="checkbox" id="fullscreenToggle" />
                        <span><i class="fas fa-expand-arrows-alt" style="margin-right:0.25rem; color:var(--vlc-orange);"></i><strong>Fullscreen Mode</strong></span>
                    </label>
                    <div style="margin-top:0.25rem; color:var(--secondary); font-size:0.85rem; margin-left:1.85rem;">
                        <i class="fas fa-info-circle"></i> Toggle between fullscreen and windowed mode
                    </div>
                </div>
                
                <div style="display:flex; flex-direction:column; gap:0.75rem;">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="new" id="uiModeNew" checked />
                        <span><strong>NEW UI</strong> - Modern app-like interface</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="old" id="uiModeOld" />
                        <span><strong>OLD UI</strong> - Classic website layout</span>
                    </label>
                </div>
                <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.9rem;">
                    <i class="fas fa-info-circle"></i> Changes will apply immediately after saving
                </div>
            </div>
        </div>
        
        <div class="settings-buttons">
            <button class="api-btn api-btn-secondary" id="cancelSettings">
                <i class="fas fa-times"></i>
                Cancel
            </button>
            <button class="api-btn api-btn-primary" id="saveSettings">
                <i class="fas fa-save"></i>
                Save Changes
            </button>
        </div>
    </div>
</div>

<!-- MPV Install Helper Modal removed -->

<!-- App Container for New UI -->
<div class="app-container">
    <!-- Sidebar Navigation (New UI Only) -->
    <aside class="app-sidebar">
        <div class="sidebar-logo" id="sidebarLogo" style="cursor: pointer;">
            <i class="fas fa-play-circle"></i>
            <div><span style="color: var(--vlc-orange);">Play</span>Torrio</div>
        </div>
        
        <div class="sidebar-divider"></div>
        
        <nav class="sidebar-nav">
            <div class="nav-section-title">DISCOVER</div>
            <div class="nav-item active" data-page="home">
                <i class="fas fa-home"></i>
                <span>Home</span>
                <span class="nav-badge">New</span>
            </div>
            <div class="nav-item" data-page="genres">
                <i class="fas fa-layer-group"></i>
                <span>Genres</span>
            </div>
            <div class="nav-item" data-page="my-list">
                <i class="fas fa-heart"></i>
                <span>My List</span>
            </div>
            <div class="nav-item" data-page="done-watching">
                <i class="fas fa-check-circle"></i>
                <span>Done Watching</span>
            </div>
            
            <div class="nav-section-title">LIBRARY</div>
            <div class="nav-item" id="sidebarClearCache">
                <i class="fas fa-trash"></i>
                <span>Clear Cache</span>
            </div>
        </nav>
        
        <!-- Quick Actions -->
        <div class="sidebar-quick-actions">
            <div class="quick-action-title">QUICK ACTIONS</div>
            <button class="quick-action-btn" id="quickRefresh">
                <i class="fas fa-sync-alt"></i>
                <span>Refresh</span>
            </button>
        </div>
        
        <div class="sidebar-footer">
            <div class="sidebar-user-info">
                <i class="fas fa-user-circle"></i>
                <span>Local User</span>
            </div>
            <button class="btn btn-primary" id="sidebarSettings" style="width: 100%; margin-top: 0.5rem;">
                <i class="fas fa-cog"></i> Settings
            </button>
        </div>
    </aside>
    
    <!-- Main App Content -->
    <div class="app-main">
        <!-- Header -->
        <header>
        <div class="header-container">
        <a class="logo" href="http://localhost:3000">
        <i class="fas fa-play-circle"></i>
        <span>Play</span> Torrio
                    </a>
        <div class="search-container">
        <i class="fas fa-search search-icon"></i>
        <input id="searchInput" placeholder="Search for movies, shows, actors..." type="text"/>
        </div>
        <div class="user-actions">
        <!-- Connection Status (NEW UI only) -->
        <div class="connection-status">
            <i class="fas fa-circle"></i>
            <span>Connected</span>
        </div>
        <button class="btn btn-outline" id="headerDonateBtn">
        <i class="fas fa-heart"></i> Donate
                        </button>
        <button class="btn btn-outline" id="genresBtn">
        <i class="fas fa-layer-group"></i> Genres
                        </button>
        <button class="btn btn-outline" id="myListBtn">
        <i class="fas fa-heart"></i> My List
                        </button>
        <button class="btn btn-outline" id="doneWatchingBtn">
        <i class="fas fa-check-circle"></i> Done Watching
                        </button>
        <button class="btn btn-outline" id="clearCacheBtn">
        <i class="fas fa-trash"></i> Clear Cache
                        </button>
        <!-- Install MPV button removed -->
        <button class="btn btn-primary" id="settingsBtn">
        <i class="fas fa-cog"></i> Settings
                        </button>
        </div>
        </div>
        </header>

<!-- Main Content -->
<main>
    <!-- Home Page -->
    <div id="homePage">
        <!-- Enhanced Title Bar with Stats -->
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title" id="homePageTitle">
                    <i class="fas fa-fire" id="homePageIcon"></i> <span id="homePageText">Trending Now</span>
                </h2>
                <p class="page-subtitle">Discover the most popular content this week</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="sortBtn">
                    <i class="fas fa-sort-amount-down"></i>
                    <span>Sort</span>
                </button>
                <button class="action-btn" id="filterBtn">
                    <i class="fas fa-filter"></i>
                    <span>Filter</span>
                </button>
            </div>
        </div>
        
        <div class="categories">
            <div class="category active" data-category="all">
                <i class="fas fa-th"></i> All
            </div>
            <div class="category" data-category="movie">
                <i class="fas fa-film"></i> Movies
            </div>
            <div class="category" data-category="tv">
                <i class="fas fa-tv"></i> TV Shows
            </div>
        </div>
        <div class="movies-grid" id="moviesGrid">
            <!-- Movie cards will be loaded here -->
        </div>
        <div class="loading" id="loadingIndicator">
            <i class="fas fa-spinner"></i> Loading more content...
        </div>
    </div>

    <!-- Genres Page -->
    <div id="genresPage" style="display: none;">
        <h2 class="section-title">
            <i class="fas fa-layer-group"></i> Genres
        </h2>
        <div class="genre-grid" id="genresGrid">
            <!-- Genre boxes will be loaded here -->
        </div>
        <div class="loading" id="genresLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading genres...
        </div>
    </div>

    <!-- Genre Details Page -->
    <div id="genreDetailsPage" style="display: none;">
        <div class="genre-header">
            <h2 class="section-title" id="genreHeaderTitle">
                <i class="fas fa-tags"></i> <span id="genreTitle">Genre</span>
            </h2>
            <div class="genre-controls">
                <button class="toggle-btn" id="toggleMovies">Movies</button>
                <button class="toggle-btn" id="toggleTV">TV Shows</button>
            </div>
        </div>
        <div class="genre-results-grid" id="genreResultsGrid">
            <!-- Genre media items will be loaded here -->
        </div>
        <div class="loading" id="genreLoadingIndicator" style="display:none;">
            <i class="fas fa-spinner"></i> Loading more...
        </div>
        <div class="loading" id="genreEmptyMessage" style="display:none;">
            <i class="fas fa-info-circle"></i> No results found for this selection.
        </div>
    </div>

    <!-- My List Page -->
    <div id="myListPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-heart"></i> <span>My List</span>
                </h2>
                <p class="page-subtitle">Your personal collection of movies and shows</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearMyListBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="myListGrid">
            <!-- My list items will be loaded here -->
        </div>
        <div class="loading" id="myListLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your list...
        </div>
        <div class="loading" id="myListEmpty" style="display:none;">
            <i class="fas fa-heart-broken"></i> Your list is empty. Start adding movies and shows!
        </div>
    </div>

    <!-- Done Watching Page -->
    <div id="doneWatchingPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-check-circle"></i> <span>Done Watching</span>
                </h2>
                <p class="page-subtitle">Movies and shows you've finished watching</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearDoneWatchingBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="doneWatchingGrid">
            <!-- Done watching items will be loaded here -->
        </div>
        <div class="loading" id="doneWatchingLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your completed items...
        </div>
        <div class="loading" id="doneWatchingEmpty" style="display:none;">
            <i class="fas fa-check-circle"></i> No completed items yet. Mark movies and shows as done when you finish watching!
        </div>
    </div>
</main>
    </div> <!-- End app-main -->
</div> <!-- End app-container -->

<!-- Movie/Show Details Modal -->
<div class="modal" id="detailsModal">
<div class="modal-content">
<button class="modal-close" id="modalClose">
<i class="fas fa-times"></i>
</button>
<div class="modal-header">
<img alt="Backdrop" class="modal-backdrop" id="modalBackdrop" src=""/>
<div class="modal-header-content">
<img alt="Poster" class="modal-poster" id="modalPoster" src=""/>
<div>
<h1 class="modal-title" id="modalTitle">Movie Title</h1>
<div class="modal-info">
<div class="modal-rating">
<i class="fas fa-star"></i> <span id="modalRating">0.0</span>
</div>
<div class="modal-year" id="modalYear">2023</div>
<div class="modal-runtime" id="modalRuntime">120 min</div>
</div>
<p class="modal-tagline" id="modalTagline">Tagline goes here</p>
<button class="btn btn-primary" id="watchNowBtn">
<i class="fas fa-play"></i> Find Torrents
                        </button>
</div>
</div>
</div>
<div class="modal-body">
<h3 class="modal-section-title">
<i class="fas fa-book-open"></i> Overview
                </h3>
<p class="modal-overview" id="modalOverview">Overview goes here...</p>

<!-- Seasons selector for TV shows -->
<div class="seasons-container" id="seasonsContainer" style="display: none;">
<h3 class="modal-section-title">
<i class="fas fa-tv"></i> Seasons
                    </h3>
<div class="season-selector" id="seasonSelector">
<!-- Seasons buttons will be loaded here -->
</div>
<h3 class="modal-section-title">
<i class="fas fa-list"></i> Episodes
                    </h3>
<div class="episodes-grid" id="episodesGrid">
<!-- Episodes will be loaded here -->
</div>
</div>

<h3 class="modal-section-title">
<i class="fas fa-users"></i> Cast
                </h3>
<div class="cast-grid" id="castGrid">
<!-- Cast members will be loaded here -->
</div>

<h3 class="modal-section-title">
<i class="fas fa-thumbs-up"></i> Similar Content
                </h3>
<div class="similar-grid" id="similarGrid">
<!-- Similar movies/shows will be loaded here -->
</div>

<!-- Torrents section -->
<div class="torrents-container" id="torrentsContainer">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-magnet"></i> Available Torrents
                        </h3>
<div class="torrent-actions">
<button class="btn btn-outline" id="refreshTorrents">
<i class="fas fa-sync"></i> Refresh
                            </button>
</div>
</div>
<div class="torrents-list" id="torrentsList">
<!-- Torrents will be loaded here -->
</div>
</div>
</div>
</div>
</div>

<!-- MPV Player -->
<div class="vlc-player-container" id="mpvPlayerContainer">
<div class="vlc-player-header">
<div class="vlc-player-title" id="mpvPlayerTitle">MPV Torrent Player <span class="source-badge webtorrent" id="streamSourceBadge" title="Streaming source">WebTorrent</span></div>
<button class="vlc-player-close" id="closePlayerBtn">
<i class="fas fa-times"></i> Close Player
            </button>
</div>
<div class="vlc-player-content">
<div class="file-selector" id="fileSelector">
<h3><i class="fas fa-folder-open"></i> Select File to Play</h3>
<div class="file-list" id="fileList">
<!-- Files will be loaded here -->
</div>
</div>

<div class="subtitle-controls" id="subtitleControls" style="display: none;">
<h4><i class="fas fa-closed-captioning"></i> Available Subtitles:</h4>
<div id="subtitleList">
<!-- Subtitle files will be loaded here -->
</div>
</div>

<div class="vlc-player-area" id="mpvPlayerArea">
<div class="vlc-loading" id="mpvLoading">
<i class="fas fa-spinner"></i>
<span>Loading</span>
</div>
</div>

<div class="vlc-controls" id="mpvControls" style="display: none;">
    <button class="vlc-btn secondary" id="copyStreamBtn">
        <i class="fas fa-copy"></i> Copy Link
    </button>
    <button class="vlc-btn" id="playNowBtn">
        <i class="fas fa-play"></i> Play Now
    </button>
    <button class="vlc-btn" id="openMPVBtn">
        <i class="fas fa-external-link-alt"></i> Open in MPV
    </button>
</div>
</div>
</div>

<!-- Custom Video Player -->
<div class="custom-player-container" id="customPlayerContainer">
<div class="player-header">
<div class="player-title" id="customPlayerTitle">
<i class="fas fa-play-circle"></i>
<span>Custom Player</span> <span class="source-badge webtorrent" id="customSourceBadge" title="Streaming source">WebTorrent</span>
</div>
<div class="player-actions">
<button class="close-player-btn" id="closeCustomPlayer">
<i class="fas fa-times"></i> Close
</button>
</div>
</div>


<div class="video-container" id="videoContainer">
<video class="custom-video video-js" id="customVideo" preload="metadata">
<source id="videoSource" src="" type="video/mp4">
Your browser does not support the video tag.
</video>

<div class="loading-overlay" id="loadingOverlay">
<i class="fas fa-spinner"></i>
<span>Loading video...</span>
</div>

<div class="subtitle-display" id="subtitleDisplay"></div>

<div class="video-controls" id="videoControls">
<div class="progress-container">
<div class="progress-bar" id="progressBar">
<div class="progress-filled" id="progressFilled"></div>
</div>
<div class="progress-time">
<span id="currentTime">0:00</span>
<span id="totalTime">0:00</span>
</div>
</div>

<div class="control-bar">
    <div class="control-left">
        <button class="control-btn" id="rewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
        <button class="control-btn play-pause" id="playPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
        <button class="control-btn" id="forwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
    </div>
    <div class="control-right">
        <div class="volume-group">
                <button class="control-btn" id="htmlMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                <input type="range" id="htmlVolume" class="volume-slider" min="0" max="100" value="80" />
        </div>
        <button class="control-btn" id="htmlSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
        <button class="control-btn" id="fullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
    </div>
</div>
</div>
</div>
<div class="subs-panel" id="htmlSubsPanel" style="right: 1rem; bottom: 6rem;">
    <div class="subs-header">
        <div>Subtitles</div>
        <div class="menu-actions">
            <button class="menu-refresh" id="htmlSubsClose">Close</button>
        </div>
    </div>
    
    <!-- Upload Section -->
    <div class="subs-upload">
        <input type="file" id="subtitleFile" accept=".srt,.vtt,.ass,.ssa" style="display:none;" />
        <button class="subs-upload-btn" id="htmlSubsUploadBtn">
            <i class="fas fa-upload"></i> Upload Subtitle File
        </button>
    </div>
    
    <!-- Customization Section -->
    <div class="subs-divider"></div>
    <div class="subs-settings">
        <div class="subs-setting-row">
            <label for="subsSize">Size</label>
            <input type="range" id="subsSize" min="12" max="48" value="22">
            <span class="subs-setting-value" id="subsSizeValue">22px</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsColor">Color</label>
            <input type="color" id="subsColor" value="#ffffff">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackground">Background</label>
            <input type="color" id="subsBackground" value="#000000">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackgroundOpacity">BG Opacity</label>
            <input type="range" id="subsBackgroundOpacity" min="0" max="100" value="75">
            <span class="subs-setting-value" id="subsOpacityValue">75%</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsFont">Font</label>
            <select id="subsFont">
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Courier New', monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Times New Roman', serif">Times New Roman</option>
                <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                <option value="Impact, fantasy">Impact</option>
            </select>
        </div>
    </div>
    
    <div class="subs-divider"></div>
    <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
    <div id="htmlSubsList"></div>
</div>
</div>

<!-- WCJS (WebChimera) Player -->
<div class="wcjs-player-container" id="wcjsPlayerContainer" style="opacity:0;pointer-events:none;">
    <div class="player-header">
        <div class="player-title" id="wcjsPlayerTitle">
            <i class="fas fa-vial"></i>
            <span>WebChimera Player</span>
        </div>
        <div class="player-actions">
            <div class="subtitle-upload">
                <input type="file" id="wcjsSubtitleFile" accept=".srt,.vtt,.ass,.ssa" />
                <label for="wcjsSubtitleFile" class="upload-btn">
                    <i class="fas fa-upload"></i> Upload Subtitles
                </label>
            </div>
            <button class="close-player-btn" id="closeWcjsPlayer">
                <i class="fas fa-times"></i> Close
            </button>
        </div>
    </div>

    <style>
        .wcjs-player-container { position: fixed; inset: 0; background:#000; z-index: 3500; display:flex; flex-direction:column; overflow: hidden; }
        .wcjs-canvas-container { flex: 1; position: relative; background:#000; display:flex; align-items:center; justify-content:center; min-height: 0; min-width: 0; overflow: hidden; }
        #wcjsCanvas { width: 100%; height: 100%; display:block; }
        .wcjs-loading { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color: var(--vlc-orange); background: rgba(0,0,0,0.8); font-size:1.2rem; }
        .volume-group { display:flex; align-items:center; gap:0.5rem; margin-left: 1rem; }
        .volume-slider { width: 120px; }
    </style>

    <div class="wcjs-canvas-container">
        <canvas id="wcjsCanvas"></canvas>
        <div class="wcjs-loading" id="wcjsLoading" style="display:none;">
            <i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i>
            <span style="margin-left:0.75rem;">Loading stream...</span>
        </div>
        <div class="video-controls" id="wcjsControls" style="display:block;">
            <div class="progress-container">
                <div class="progress-bar" id="wcjsProgressBar">
                    <div class="progress-filled" id="wcjsProgressFilled"></div>
                </div>
                <div class="progress-time">
                    <span id="wcjsCurrentTime">0:00</span>
                    <span id="wcjsTotalTime">0:00</span>
                </div>
            </div>

            <div class="control-buttons">
                <button class="control-btn" id="wcjsRewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
                <button class="control-btn play-pause" id="wcjsPlayPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
                <button class="control-btn" id="wcjsForwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
                <div class="volume-group">
                    <button class="control-btn" id="wcjsMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                    <input type="range" id="wcjsVolume" class="volume-slider" min="0" max="100" value="80" />
                </div>
                <button class="control-btn" id="wcjsSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
                <button class="control-btn" id="wcjsAudioBtn" title="Audio Tracks"><i class="fas fa-headphones"></i></button>
                <button class="control-btn fullscreen-btn" id="wcjsFullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
            </div>
        </div>
    </div>
    <div class="subs-panel" id="wcjsSubsPanel">
        <div class="subs-header">
            <div>Subtitles</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsSubsRefresh">Refresh</button>
                <button class="menu-refresh" id="wcjsSubsClose">Close</button>
            </div>
        </div>
        <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
        <div id="wcjsSubsList"></div>
    </div>
    <div class="subs-panel" id="wcjsAudioPanel" style="right: 360px;">
        <div class="subs-header">
            <div>Audio Tracks</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsAudioClose">Close</button>
            </div>
        </div>
        <div id="wcjsAudioList"></div>
    </div>
</div>

<!-- Notification -->
<div class="notification" id="notification">Action completed!</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<!-- Video.js JavaScript -->
<script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
<script>
        // UI Mode Management
        let currentUIMode = localStorage.getItem('uiMode') || 'new';
        
        // Apply UI mode on page load
        function applyUIMode(mode) {
            currentUIMode = mode;
            document.body.classList.remove('ui-old', 'ui-new');
            document.body.classList.add(`ui-${mode}`);
            localStorage.setItem('uiMode', mode);
        }
        
        // Initialize UI mode immediately (before DOM loads)
        applyUIMode(currentUIMode);
        
        // API configuration
        const TMDB_API_KEY = 'b3556f3b206e16f82df4d1f6fd4545e6';
        const API_BASE_URL = 'http://localhost:3000/api';
        
        // DOM elements - Home
        const moviesGrid = document.getElementById('moviesGrid');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const homePageEl = document.getElementById('homePage');

        // DOM elements - Genres
        const genresBtn = document.getElementById('genresBtn');
        const genresPageEl = document.getElementById('genresPage');
        const genresGrid = document.getElementById('genresGrid');
        const genresLoading = document.getElementById('genresLoading');

        // DOM elements - Genre Details
        const genreDetailsPageEl = document.getElementById('genreDetailsPage');
        const genreTitleEl = document.getElementById('genreTitle');
        const toggleMoviesBtn = document.getElementById('toggleMovies');
        const toggleTVBtn = document.getElementById('toggleTV');
        const genreResultsGrid = document.getElementById('genreResultsGrid');
        const genreLoadingIndicator = document.getElementById('genreLoadingIndicator');
        const genreEmptyMessage = document.getElementById('genreEmptyMessage');

        // DOM elements - Modal and others
        const detailsModal = document.getElementById('detailsModal');
        const modalClose = document.getElementById('modalClose');
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalPoster = document.getElementById('modalPoster');
        const modalTitle = document.getElementById('modalTitle');
        const modalRating = document.getElementById('modalRating');
        const modalYear = document.getElementById('modalYear');
        const modalRuntime = document.getElementById('modalRuntime');
        const modalTagline = document.getElementById('modalTagline');
        const modalOverview = document.getElementById('modalOverview');
        const castGrid = document.getElementById('castGrid');
        const similarGrid = document.getElementById('similarGrid');
        const torrentsList = document.getElementById('torrentsList');
        const notification = document.getElementById('notification');
        const watchNowBtn = document.getElementById('watchNowBtn');
        const seasonsContainer = document.getElementById('seasonsContainer');
        const seasonSelector = document.getElementById('seasonSelector');
        const episodesGrid = document.getElementById('episodesGrid');
        const refreshTorrents = document.getElementById('refreshTorrents');
        const torrentsContainer = document.getElementById('torrentsContainer');
        
        // API Setup Modal elements
        const apiSetupModal = document.getElementById('apiSetupModal');
        const firstTimeApiKey = document.getElementById('firstTimeApiKey');
        const saveFirstTimeApiKey = document.getElementById('saveFirstTimeApiKey');
    const openJackettLinkBtn = document.getElementById('openJackettLink');
        
        // Donate Modal elements
        const donateModal = document.getElementById('donateModal');
        const donateClose = document.getElementById('donateClose');
        const donateButton = document.getElementById('donateButton');
        const headerDonateBtn = document.getElementById('headerDonateBtn');
        
        // Settings Modal elements
        const settingsModal = document.getElementById('settingsModal');
    const settingsBtn = document.getElementById('settingsBtn');
    const clearCacheBtn = document.getElementById('clearCacheBtn');
        const settingsClose = document.getElementById('settingsClose');
        const currentApiKey = document.getElementById('currentApiKey');
        const newApiKey = document.getElementById('newApiKey');
        const saveSettings = document.getElementById('saveSettings');
        const cancelSettings = document.getElementById('cancelSettings');
        const useTorrentlessToggle = document.getElementById('useTorrentlessToggle');
    // Debrid controls
    const useDebridToggle = document.getElementById('useDebridToggle');
    const debridProviderSel = document.getElementById('debridProvider');
    const debridStatus = document.getElementById('debridStatus');
    const debridTokenInput = document.getElementById('debridToken');
    const saveDebridTokenBtn = document.getElementById('saveDebridToken');
    const clearDebridTokenBtn = document.getElementById('clearDebridToken');
    const rdClientIdInput = document.getElementById('rdClientId');
    const rdDeviceLoginBtn = document.getElementById('rdDeviceLogin');
    const rdClientIdGroup = document.getElementById('rdClientIdGroup');
    const rdButtons = document.getElementById('rdButtons');
    const rdTokenGroup = document.getElementById('rdTokenGroup');
    const rdTokenButtons = document.getElementById('rdTokenButtons');
    const rdCodePanel = document.getElementById('rdCodePanel');
    const rdUserCodeEl = document.getElementById('rdUserCode');
    const rdVerifyUrlEl = document.getElementById('rdVerifyUrl');
    const rdOpenVerifyBtn = document.getElementById('rdOpenVerify');
    const rdCopyCodeBtn = document.getElementById('rdCopyCode');
    const rdCancelLoginBtn = document.getElementById('rdCancelLogin');
    const rdLoginStatusEl = document.getElementById('rdLoginStatus');
    // AllDebrid controls
    const adSection = document.getElementById('adSection');
    const adStartPinBtn = document.getElementById('adStartPin');
    const adPinPanel = document.getElementById('adPinPanel');
    const adPinCodeEl = document.getElementById('adPinCode');
    const adUserUrlEl = document.getElementById('adUserUrl');
    const adOpenUserUrlBtn = document.getElementById('adOpenUserUrl');
    const adCopyPinBtn = document.getElementById('adCopyPin');
    const adCancelPinBtn = document.getElementById('adCancelPin');
    const adLoginStatusEl = document.getElementById('adLoginStatus');
    const adApiKeyInput = document.getElementById('adApiKey');
    const adSaveApiKeyBtn = document.getElementById('adSaveApiKey');
    const adClearApiKeyBtn = document.getElementById('adClearApiKey');
    // TorBox controls
    const tbSection = document.getElementById('tbSection');
    const tbTokenInput = document.getElementById('tbToken');
    const tbSaveTokenBtn = document.getElementById('tbSaveToken');
    const tbClearTokenBtn = document.getElementById('tbClearToken');
    // Premiumize controls
    const pmSection = document.getElementById('pmSection');
    const pmApiKeyInput = document.getElementById('pmApiKey');
    const pmSaveApiKeyBtn = document.getElementById('pmSaveApiKey');
    const pmClearApiKeyBtn = document.getElementById('pmClearApiKey');
        
        // MPV Player elements
        const mpvPlayerContainer = document.getElementById('mpvPlayerContainer');
        const playerTitle = document.getElementById('mpvPlayerTitle');
        const closePlayerBtn = document.getElementById('closePlayerBtn');
        const fileSelector = document.getElementById('fileSelector');
        const fileList = document.getElementById('fileList');
        const subtitleControls = document.getElementById('subtitleControls');
        const subtitleList = document.getElementById('subtitleList');
        const mpvPlayerArea = document.getElementById('mpvPlayerArea');
        const mpvLoading = document.getElementById('mpvLoading');
    const mpvControls = document.getElementById('mpvControls');
        // Helper: get base filename from a path
        function baseName(p) {
            try { return String(p || '').split(/[\\\/]/).pop(); } catch(_) { return p || ''; }
        }
        const openMPVBtn = document.getElementById('openMPVBtn');
        const copyStreamBtn = document.getElementById('copyStreamBtn');
    const playNowBtn = document.getElementById('playNowBtn');
    const streamSourceBadge = document.getElementById('streamSourceBadge');

        // Custom Player elements
        const customPlayerContainer = document.getElementById('customPlayerContainer');
        const customPlayerTitle = document.getElementById('customPlayerTitle');
    const customSourceBadge = document.getElementById('customSourceBadge');
        const closeCustomPlayer = document.getElementById('closeCustomPlayer');
        const customVideo = document.getElementById('customVideo');
        const videoSource = document.getElementById('videoSource');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const subtitleDisplay = document.getElementById('subtitleDisplay');
        const videoControls = document.getElementById('videoControls');
        const progressBar = document.getElementById('progressBar');
        const progressFilled = document.getElementById('progressFilled');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const subtitleFile = document.getElementById('subtitleFile');
    const htmlMuteBtn = document.getElementById('htmlMuteBtn');
    const htmlVolume = document.getElementById('htmlVolume');
    const htmlSubsBtn = document.getElementById('htmlSubsBtn');
    const htmlSubsPanel = document.getElementById('htmlSubsPanel');
    const htmlSubsList = document.getElementById('htmlSubsList');
    const htmlSubsClose = document.getElementById('htmlSubsClose');
    
    // Subtitle customization elements
    const htmlSubsUploadBtn = document.getElementById('htmlSubsUploadBtn');
    const subsSizeInput = document.getElementById('subsSize');
    const subsSizeValue = document.getElementById('subsSizeValue');
    const subsColorInput = document.getElementById('subsColor');
    const subsBackgroundInput = document.getElementById('subsBackground');
    const subsBackgroundOpacityInput = document.getElementById('subsBackgroundOpacity');
    const subsOpacityValue = document.getElementById('subsOpacityValue');
    const subsFontSelect = document.getElementById('subsFont');
    
    // Subtitle settings
    let subtitleSettings = {
        size: 22,
        color: '#ffffff',
        background: '#000000',
        backgroundOpacity: 75,
        font: 'Arial, sans-serif'
    };

    // WCJS Player elements
    const wcjsPlayerContainer = document.getElementById('wcjsPlayerContainer');
    const wcjsPlayerTitle = document.getElementById('wcjsPlayerTitle');
    const wcjsCanvas = document.getElementById('wcjsCanvas');
    const wcjsLoading = document.getElementById('wcjsLoading');
    const closeWcjsPlayer = document.getElementById('closeWcjsPlayer');
    const wcjsControls = document.getElementById('wcjsControls');
    const wcjsProgressBar = document.getElementById('wcjsProgressBar');
    const wcjsProgressFilled = document.getElementById('wcjsProgressFilled');
    const wcjsCurrentTime = document.getElementById('wcjsCurrentTime');
    const wcjsTotalTime = document.getElementById('wcjsTotalTime');
    const wcjsPlayPauseBtn = document.getElementById('wcjsPlayPauseBtn');
    const wcjsRewindBtn = document.getElementById('wcjsRewindBtn');
    const wcjsForwardBtn = document.getElementById('wcjsForwardBtn');
    const wcjsFullscreenBtn = document.getElementById('wcjsFullscreenBtn');
    const wcjsMuteBtn = document.getElementById('wcjsMuteBtn');
    const wcjsVolume = document.getElementById('wcjsVolume');
    const wcjsSubtitleFile = document.getElementById('wcjsSubtitleFile');
    const wcjsSubsBtn = document.getElementById('wcjsSubsBtn');
    const wcjsAudioBtn = document.getElementById('wcjsAudioBtn');
    const wcjsSubsPanel = document.getElementById('wcjsSubsPanel');
    const wcjsAudioPanel = document.getElementById('wcjsAudioPanel');
    const wcjsSubsList = document.getElementById('wcjsSubsList');
    const wcjsAudioList = document.getElementById('wcjsAudioList');
    const wcjsSubsRefresh = document.getElementById('wcjsSubsRefresh');
    const wcjsSubsClose = document.getElementById('wcjsSubsClose');
    const wcjsAudioClose = document.getElementById('wcjsAudioClose');
        
        // Global variables
    let currentPage = 1; // home page pagination
        let isLoading = false; // route-scoped loading flag
        let currentContent = null;
        let currentMediaType = 'movie';
        let currentSeason = 1;
        let torrentsLoaded = false;
        let currentTorrentData = null;
        let currentStreamUrl = null;
    let currentSelectedVideoName = null; // track selected torrent file name
        let currentSubtitleUrl = null;
        let currentSubtitles = [];
    let subtitleTrack = null;
    let currentSubtitleFile = null; // filename served under /subtitles to delete on switch
    
    // Sort and Filter state
    let currentSort = 'popularity'; // popularity, rating, date
    let currentFilter = 'all'; // all, hd, 4k
    let allMoviesCache = []; // Cache for sorting/filtering
    
    // Resume state
    let resumeKey = null; // stable key per item (provider/hash/file or direct link)
    let resumeInfo = null; // { position, duration, updatedAt }
    let resumeTimer = null;
    let lastResumeSend = 0;
    let hasApiKey = false;
    let useTorrentless = false; // global toggle for Torrentless mode
    let useDebrid = false; // global toggle for Debrid
    let debridAuth = false; // token presence depending on provider
    let debridProvider = 'realdebrid';
        let currentCategory = 'all';
        let allTorrents = [];
        let torrentsPage = 1;
        const torrentsPerPage = 20;

        // Cache for filename -> TMDB lookup
        const filenameTmdbCache = new Map();

        // Parse title/season/episode from a torrent filename
        function parseFromFilename(name = '') {
            try {
                const base = String(name).replace(/\.[^.]+$/,'');
                const cleaned = base
                    .replace(/[\[\(].*?[\)\]]/g, ' ')
                    .replace(/[_]+/g,' ')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const patterns = [
                    { re: /(s)(\d{1,2})[ ._-]*e(\d{1,3})/i, season: 2, episode: 3 },
                    { re: /\b(\d{1,2})[xX](\d{1,3})\b/, season: 1, episode: 2 },
                    { re: /\b(\d{1,2})[ ._-]+(\d{1,2})\b/, season: 1, episode: 2 },
                ];
                let season = null, episode = null, title = cleaned, m = null, idx = -1;
                for (const p of patterns) {
                    const mm = cleaned.match(p.re);
                    if (mm) {
                        const sVal = parseInt(mm[p.season], 10);
                        const eVal = parseInt(mm[p.episode], 10);
                        if (!isNaN(sVal) && !isNaN(eVal) && sVal <= 99 && eVal <= 999) {
                            season = sVal; episode = eVal; m = mm; idx = mm.index; break;
                        }
                    }
                }
                if (m && idx >= 0) title = cleaned.slice(0, idx).replace(/[-_.]+$/,'').trim();
                title = title
                    .replace(/\b(\d{3,4}p|4k|bluray|web[- ]?dl|webrip|bdrip|hdr|dv|x264|x265|hevc|h264)\b/ig, '')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const type = season && episode ? 'tv' : 'movie';
                return { title, season, episode, type };
            } catch { return { title: '', season: null, episode: null, type: 'movie' }; }
        }

        async function getTmdbFromFilename(filename) {
            if (!filename) return null;
            if (filenameTmdbCache.has(filename)) return filenameTmdbCache.get(filename);
            const parsed = parseFromFilename(filename);
            const result = { id: null, type: parsed.type, season: parsed.season, episode: parsed.episode, title: parsed.title };
            if (!parsed.title) { filenameTmdbCache.set(filename, result); return result; }
            try {
                const endpoint = parsed.type === 'tv' ? 'search/tv' : 'search/movie';
                const url = `https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(parsed.title)}`;
                const resp = await fetch(url);
                if (resp.ok) {
                    const data = await resp.json();
                    const items = Array.isArray(data.results) ? data.results : [];
                    if (items.length) {
                        result.id = items[0].id;
                    }
                }
            } catch {}
            filenameTmdbCache.set(filename, result);
            return result;
        }

        // Routing and genres state
        let activeRoute = 'home';
        let genresMap = new Map(); // nameLower -> { name, movieId?, tvId? }
        let genresLoaded = false;
        let currentGenre = null; // {name, movieId?, tvId?}
        let currentGenreType = 'movie'; // 'movie' | 'tv'
        let genreCurrentPage = 1;

        // Initialize the app
        async function init() {
            await checkApiKeyStatus();
            await ensureDebridState();
            setupEventListeners();
            handleRoute(); // route-aware initial load
            checkFirstLaunch(); // Show donate modal on first launch
        }
        
        // Check if this is the first launch and show donate modal
        function checkFirstLaunch() {
            const hasSeenDonateModal = localStorage.getItem('hasSeenDonateModal');
            if (!hasSeenDonateModal) {
                // Wait a bit for the page to fully load before showing the donate modal
                setTimeout(() => {
                    showDonateModal();
                    localStorage.setItem('hasSeenDonateModal', 'true');
                }, 500);
            }
        }

        // Get provider display name for notifications and UI
        function getProviderDisplayName(provider) {
            switch(provider) {
                case 'alldebrid': return 'AllDebrid';
                case 'torbox': return 'TorBox';
                case 'premiumize': return 'Premiumize';
                case 'realdebrid':
                default: return 'Real‑Debrid';
            }
        }

        // Ensure debrid flags are loaded at startup and before streaming
        async function ensureDebridState() {
            try {
                const r = await fetch(`${API_BASE_URL}/settings`);
                if (r.ok) {
                    const s = await r.json();
                    useDebrid = !!s.useDebrid;
                    debridAuth = !!s.debridAuth;
                    debridProvider = s.debridProvider || 'realdebrid';
                    console.log('[UI][Debrid] state', { useDebrid, debridAuth, debridProvider });
                }
            } catch (e) { console.warn('[UI][Debrid] state load failed', e?.message); }
        }
        
        // Check API key status
        async function checkApiKeyStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/check-api-key`);
                const data = await response.json();
                hasApiKey = data.hasApiKey;
                useTorrentless = !!data.useTorrentless;
                if (!hasApiKey && !useTorrentless) {
                    showApiSetupModal();
                } else {
                    await loadCurrentApiKey();
                    hideApiSetupModal();
                }
            } catch (error) {
                console.error('Error checking API key status:', error);
                // If server is not up yet, still prompt the user to install Jackett / set API key
                showApiSetupModal();
                showNotification('Local server not ready. Enter Jackett key or choose Watch without Jackett.');
            }
        }
        
        // Load current API key for display
        async function loadCurrentApiKey() {
            try {
                const response = await fetch(`${API_BASE_URL}/get-api-key`);
                const data = await response.json();
                
                if (data.hasApiKey) {
                    currentApiKey.textContent = `Current: ${data.apiKey}`;
                } else {
                    currentApiKey.textContent = 'No API key configured';
                }
            } catch (error) {
                console.error('Error loading current API key:', error);
                // Also fetch debrid settings for global flags
                try {
                    const sres = await fetch(`${API_BASE_URL}/settings`);
                    if (sres.ok) {
                        const s = await sres.json();
                        useDebrid = !!s.useDebrid;
                        debridAuth = !!s.debridAuth;
                    }
                } catch(_) {}
                currentApiKey.textContent = 'Error loading API key';
            }
        }
        
        // Show API setup modal
        function showApiSetupModal() {
            apiSetupModal.classList.add('active');
            document.body.style.overflow = 'hidden';
            // Notify user to install Jackett and provide API key, or use Torrentless
            showNotification('Enter Jackett API key or choose Watch without Jackett (fewer sources, slower buffering).');
        }
        
        // Hide API setup modal
        function hideApiSetupModal() {
            apiSetupModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Show donate modal
        function showDonateModal() {
            donateModal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Hide the close button initially
            donateClose.classList.remove('visible');
            
            // Show close button after 2 seconds
            setTimeout(() => {
                donateClose.classList.add('visible');
            }, 2000);
        }
        
        // Hide donate modal
        function hideDonateModal() {
            donateModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Show settings modal
        async function showSettingsModal() {
            await loadCurrentApiKey();
            newApiKey.value = '';
            settingsModal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Load UI mode setting
            const uiModeNew = document.getElementById('uiModeNew');
            const uiModeOld = document.getElementById('uiModeOld');
            if (uiModeNew && uiModeOld) {
                if (currentUIMode === 'new') {
                    uiModeNew.checked = true;
                } else {
                    uiModeOld.checked = true;
                }
            }
            
            // Load fullscreen setting
            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle && window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success) {
                        fullscreenToggle.checked = result.isFullscreen;
                    }
                } catch (error) {
                    console.error('Error loading fullscreen state:', error);
                }
            }
            
            // Load useTorrentless setting state
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const s = await res.json();
                    useTorrentless = !!s.useTorrentless;
                    if (useTorrentlessToggle) useTorrentlessToggle.checked = useTorrentless;
                    // Debrid: populate form
                    if (useDebridToggle) useDebridToggle.checked = !!s.useDebrid;
                    const prov = s.debridProvider || 'realdebrid';
                    if (debridProviderSel) debridProviderSel.value = prov;
                    if (debridStatus) debridStatus.textContent = s.debridAuth ? 'Logged in' : 'Not logged in';
                    if (rdClientIdInput) rdClientIdInput.value = s.rdClientId || '';
                    useDebrid = !!s.useDebrid; debridAuth = !!s.debridAuth;
                    // Toggle provider-specific UI
                    const isRD = prov === 'realdebrid';
                    const isAD = prov === 'alldebrid';
                    const isTB = prov === 'torbox';
                    if (rdClientIdGroup) rdClientIdGroup.style.display = isRD ? '' : 'none';
                    if (rdButtons) rdButtons.style.display = isRD ? '' : 'none';
                    if (rdTokenGroup) rdTokenGroup.style.display = isRD ? '' : 'none';
                    if (rdTokenButtons) rdTokenButtons.style.display = isRD ? '' : 'none';
                    if (rdCodePanel) rdCodePanel.style.display = 'none';
                    if (adSection) adSection.style.display = isAD ? '' : 'none';
                    if (tbSection) tbSection.style.display = isTB ? '' : 'none';
                }
            } catch(_) {}
        }
        
        // Hide settings modal
        function hideSettingsModal() {
            settingsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Save API key (first time setup)
        async function saveFirstTimeApiKey_() {
            const apiKey = firstTimeApiKey.value.trim();
            
            if (!apiKey) {
                showNotification('Please enter an API key');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ apiKey })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    hasApiKey = true;
                    hideApiSetupModal();
                    showNotification('API key saved successfully!');
                    await loadCurrentApiKey();
                } else {
                    showNotification(data.error || 'Failed to save API key');
                }
            } catch (error) {
                console.error('Error saving API key:', error);
                showNotification('Error saving API key');
            }
        }
        
        // Save Settings: persist useTorrentless and optionally API key, then close modal
        async function saveSettings_() {
            const apiKey = newApiKey.value.trim();
            const toggleEl = document.getElementById('useTorrentlessToggle');
            const desiredTorrentless = toggleEl ? !!toggleEl.checked : useTorrentless;
            
            // Handle fullscreen toggle
            const fullscreenToggle = document.getElementById('fullscreenToggle');
            if (fullscreenToggle && window.electronAPI && window.electronAPI.setFullscreen) {
                try {
                    const result = await window.electronAPI.setFullscreen(fullscreenToggle.checked);
                    if (!result.success) {
                        console.error('Failed to set fullscreen:', result.message);
                        showNotification('Failed to change fullscreen mode');
                    }
                } catch (error) {
                    console.error('Error setting fullscreen:', error);
                    showNotification('Error changing fullscreen mode');
                }
            }
            
            // Handle UI mode change
            const uiModeNew = document.getElementById('uiModeNew');
            const uiModeOld = document.getElementById('uiModeOld');
            let selectedUIMode = 'new';
            if (uiModeOld && uiModeOld.checked) {
                selectedUIMode = 'old';
            }
            
            // Apply UI mode change immediately
            if (selectedUIMode !== currentUIMode) {
                applyUIMode(selectedUIMode);
            }

            let apiResult = null;
            try {
                // Persist Torrentless toggle first so UI/search respects it immediately
                await fetch(`${API_BASE_URL}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ useTorrentless: desiredTorrentless })
                });
                useTorrentless = desiredTorrentless;

                // If an API key was provided, attempt to save it; otherwise skip quietly
                if (apiKey) {
                    const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ apiKey })
                    });
                    apiResult = await response.json();
                    if (response.ok) {
                        hasApiKey = true;
                        await loadCurrentApiKey();
                        showNotification('Settings saved. API key updated.');
                    } else {
                        showNotification(apiResult.error || 'Failed to update API key');
                    }
                } else {
                    showNotification('Settings saved.');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                // Even if API key call fails, close the modal when toggling Torrentless is desired
            } finally {
                hideSettingsModal();
            }
        }
        
        // Helper functions for page navigation (used by sidebar)
        function showHomePage() {
            window.location.hash = '#/';
        }
        
        function showGenresPage() {
            window.location.hash = '#/genres';
        }
        
        function showMyListPage() {
            window.location.hash = '#/my-list';
        }
        
        function showDoneWatchingPage() {
            window.location.hash = '#/done-watching';
        }
        
    function setupEventListeners() {
            // Initialize Video.js player
            if (typeof videojs !== 'undefined') {
                try {
                    window.vjsPlayer = videojs('customVideo', {
                        controls: false,
                        preload: 'metadata',
                        fluid: false,
                        fill: true
                    });
                    console.log('Video.js initialized');
                } catch (e) {
                    console.warn('Video.js initialization failed:', e);
                }
            }
            
            // API Setup Modal
            saveFirstTimeApiKey.addEventListener('click', saveFirstTimeApiKey_);
            const useTorrentlessSetupBtn = document.getElementById('useTorrentlessSetup');
            if (useTorrentlessSetupBtn) {
                useTorrentlessSetupBtn.addEventListener('click', async () => {
                    try {
                        await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useTorrentless: true }) });
                        // Also update local state so searches work immediately without reopening Settings
                        useTorrentless = true;
                        hideApiSetupModal();
                        showNotification('Watch without Jackett enabled.');
                        // If user was in the middle of searching, retry now
                        try {
                            const qEl = document.getElementById('searchInput');
                            const q = qEl && qEl.value ? qEl.value.trim() : '';
                            if (q) await searchMovies(q);
                        } catch(_) {}
                    } catch { showNotification('Failed to enable Watch without Jackett'); }
                });
            }
            const videoTutorialFirstBtn = document.getElementById('videoTutorialFirst');
            if (videoTutorialFirstBtn) {
                videoTutorialFirstBtn.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg';
                    if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(url);
                });
            }
            
            // Donate Modal
            if (donateClose) {
                donateClose.addEventListener('click', hideDonateModal);
            }
            if (donateButton) {
                donateButton.addEventListener('click', async () => {
                    const url = 'https://buymeacoffee.com/ayman228x?status=1';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            // Fallback in case preload bridge is unavailable
                            window.open(url, '_blank', 'noopener');
                        }
                    } catch(_) {}
                    // Optionally close the donate modal after opening the link
                    try { hideDonateModal(); } catch(_) {}
                });
            }
            if (headerDonateBtn) {
                headerDonateBtn.addEventListener('click', showDonateModal);
            }
            
            // Settings Modal
            settingsBtn.addEventListener('click', showSettingsModal);
            clearCacheBtn.addEventListener('click', async () => {
                const result = await window.electronAPI.clearCache();
                showNotification(result.message, !result.success);
            });
            // MPV install helpers removed
            settingsClose.addEventListener('click', hideSettingsModal);
            saveSettings.addEventListener('click', saveSettings_);
            cancelSettings.addEventListener('click', hideSettingsModal);
            const videoTutorialBtnEl = document.getElementById('videoTutorialBtn');
            if (videoTutorialBtnEl) {
                videoTutorialBtnEl.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg';
                    if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(url);
                });
            }
            // Watch without Jackett toggle
            if (useTorrentlessToggle) {
                useTorrentlessToggle.addEventListener('change', async (e) => {
                    const enabled = !!e.target.checked;
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useTorrentless: enabled })
                        });
                        if (res.ok) {
                            useTorrentless = enabled;
                            showNotification(enabled ? 'Watch without Jackett enabled.' : 'Watch without Jackett disabled.');
                        } else {
                            e.target.checked = !enabled;
                            showNotification('Failed to update setting.');
                        }
                    } catch {
                        e.target.checked = !enabled;
                        showNotification('Failed to update setting.');
                    }
                });
            }

            // Debrid settings
            if (useDebridToggle || debridProviderSel) {
                const onDebridChange = async () => {
                    const enabled = useDebridToggle ? !!useDebridToggle.checked : false;
                    const provider = debridProviderSel ? debridProviderSel.value : 'realdebrid';
                    const rdClientId = (rdClientIdInput?.value || '').trim();
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useDebrid: enabled, debridProvider: provider, rdClientId })
                        });
                        if (!res.ok) throw new Error('save failed');
                        await res.json();
                        useDebrid = enabled;
                        debridProvider = provider;
                        // Toggle provider-specific UI blocks
                        const isRD = provider === 'realdebrid';
                        const isAD = provider === 'alldebrid';
                        const isTB = provider === 'torbox';
                        const isPM = provider === 'premiumize';
                        if (rdClientIdGroup) rdClientIdGroup.style.display = isRD ? '' : 'none';
                        if (rdButtons) rdButtons.style.display = isRD ? '' : 'none';
                        if (rdTokenGroup) rdTokenGroup.style.display = isRD ? '' : 'none';
                        if (rdTokenButtons) rdTokenButtons.style.display = isRD ? '' : 'none';
                        if (rdCodePanel) rdCodePanel.style.display = 'none';
                        if (adSection) adSection.style.display = isAD ? '' : 'none';
                        if (tbSection) tbSection.style.display = isTB ? '' : 'none';
                        if (pmSection) pmSection.style.display = isPM ? '' : 'none';
                        showNotification('Debrid settings saved.');
                    } catch {
                        showNotification('Failed to save debrid settings');
                    }
                };
                if (useDebridToggle) useDebridToggle.addEventListener('change', onDebridChange);
                if (debridProviderSel) debridProviderSel.addEventListener('change', onDebridChange);
                if (rdClientIdInput) rdClientIdInput.addEventListener('change', onDebridChange);
            }

            if (saveDebridTokenBtn) {
                saveDebridTokenBtn.addEventListener('click', async () => {
                    const token = (debridTokenInput?.value || '').trim();
                    if (!token) { showNotification('Enter a token first'); return; }
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token })
                        });
                        if (res.ok) {
                            if (debridStatus) debridStatus.textContent = 'Logged in';
                            debridTokenInput.value = '';
                            showNotification('Debrid token saved.');
                        } else {
                            showNotification('Failed to save token');
                        }
                    } catch { showNotification('Failed to save token'); }
                });
            }
            if (clearDebridTokenBtn) {
                clearDebridTokenBtn.addEventListener('click', async () => {
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' })
                        });
                        if (res.ok) {
                            if (debridStatus) debridStatus.textContent = 'Not logged in';
                            showNotification('Logged out of Debrid.');
                        } else {
                            showNotification('Failed to logout');
                        }
                    } catch { showNotification('Failed to logout'); }
                });
            }

            // RD Device-code login handlers
            let rdPollTimer = null;
            function stopRdPolling() { if (rdPollTimer) { clearInterval(rdPollTimer); rdPollTimer = null; } }
            async function beginRdDeviceLogin() {
                try {
                    const clientId = (rdClientIdInput?.value || '').trim();
                    if (!clientId) { showNotification('Enter your Real‑Debrid Client ID first'); return; }
                    const url = `${API_BASE_URL}/debrid/rd/device-code${clientId ? `?client_id=${encodeURIComponent(clientId)}` : ''}`;
                    const r = await fetch(url);
                    if (!r.ok) {
                        let msg = 'RD device-code start failed';
                        try { const t = await r.json(); if (t?.error) msg = t.error; } catch { try { msg = await r.text(); } catch {} }
                        rdLoginStatusEl.textContent = 'Error starting login';
                        showNotification(msg);
                        return;
                    }
                    const j = await r.json();
                    rdCodePanel.style.display = 'block';
                    rdUserCodeEl.textContent = j.user_code || '----';
                    rdVerifyUrlEl.textContent = j.verification_url || 'https://real-debrid.com/device';
                    rdVerifyUrlEl.href = j.verification_url || 'https://real-debrid.com/device';
                    rdLoginStatusEl.textContent = 'Waiting for approval…';
                    const intervalMs = Math.max(3, Number(j.interval || 5)) * 1000;
                    const deviceCode = j.device_code;
                    // Start polling
                    stopRdPolling();
                    rdPollTimer = setInterval(async () => {
                        try {
                            const pr = await fetch(`${API_BASE_URL}/debrid/rd/poll`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ device_code: deviceCode, client_id: clientId || undefined })
                            });
                            if (pr.ok) {
                                stopRdPolling();
                                rdLoginStatusEl.textContent = 'Logged in!';
                                if (debridStatus) debridStatus.textContent = 'Logged in';
                                debridAuth = true;
                                showNotification('Real‑Debrid connected');
                                setTimeout(() => { rdCodePanel.style.display = 'none'; }, 800);
                            } else {
                                const txt = await pr.text();
                                if (/expired|invalid/i.test(txt)) {
                                    stopRdPolling();
                                    rdLoginStatusEl.textContent = 'Code expired. Try again.';
                                }
                            }
                        } catch (_) {}
                    }, intervalMs);
                } catch (_) {
                    showNotification('Failed to start device login');
                }
            }
            if (rdDeviceLoginBtn) rdDeviceLoginBtn.addEventListener('click', beginRdDeviceLogin);
            if (rdOpenVerifyBtn) rdOpenVerifyBtn.addEventListener('click', async () => {
                const href = rdVerifyUrlEl?.href || 'https://real-debrid.com/device';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href);
                else window.open(href, '_blank');
            });
            if (rdCopyCodeBtn) rdCopyCodeBtn.addEventListener('click', async () => {
                try { await navigator.clipboard.writeText(rdUserCodeEl?.textContent || ''); showNotification('Code copied'); } catch(_) {}
            });
            if (rdCancelLoginBtn) rdCancelLoginBtn.addEventListener('click', async () => {
                stopRdPolling(); rdCodePanel.style.display = 'none';
            });

            // AllDebrid PIN login handlers
            let adPollTimer = null, adPin = '', adCheck = '';
            function stopAdPolling() { if (adPollTimer) { clearInterval(adPollTimer); adPollTimer = null; } }
            async function beginAdPinLogin() {
                // If already authenticated with AllDebrid, avoid creating a new API key via PIN
                try {
                    await ensureDebridState();
                } catch {}
                if (useDebrid && debridProvider === 'alldebrid' && debridAuth) {
                    showNotification('Already logged in to AllDebrid');
                    return;
                }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/pin`);
                    const j = await r.json();
                    if (r.ok && j.pin && j.check) {
                        adPin = j.pin; adCheck = j.check;
                        if (adPinPanel) adPinPanel.style.display = 'block';
                        if (adPinCodeEl) adPinCodeEl.textContent = adPin;
                        if (adUserUrlEl) adUserUrlEl.href = j.user_url || 'https://alldebrid.com/pin/';
                        if (adLoginStatusEl) adLoginStatusEl.textContent = 'Waiting…';
                        stopAdPolling();
                        adPollTimer = setInterval(async () => {
                            try {
                                const pr = await fetch(`${API_BASE_URL}/debrid/ad/check`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin: adPin, check: adCheck }) });
                                const pj = await pr.json();
                                if (pr.ok && pj.success) {
                                    stopAdPolling();
                                    if (debridStatus) debridStatus.textContent = 'Logged in';
                                    debridAuth = true;
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = 'Logged in!';
                                    showNotification('AllDebrid connected');
                                    setTimeout(() => { if (adPinPanel) adPinPanel.style.display = 'none'; }, 800);
                                } else if (pr.ok) {
                                    // keep waiting
                                } else {
                                    stopAdPolling();
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = pj?.error || 'PIN expired';
                                }
                            } catch (_) {}
                        }, 5000);
                    } else {
                        showNotification(j?.error || 'Failed to start AllDebrid PIN');
                    }
                } catch (_) {
                    showNotification('Failed to start AllDebrid PIN');
                }
            }
            if (adStartPinBtn) adStartPinBtn.addEventListener('click', beginAdPinLogin);
            if (adOpenUserUrlBtn) adOpenUserUrlBtn.addEventListener('click', async () => {
                const href = adUserUrlEl?.href || 'https://alldebrid.com/pin/';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank');
            });
            if (adCopyPinBtn) adCopyPinBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(adPinCodeEl?.textContent || ''); showNotification('PIN copied'); } catch(_) {} });
            if (adCancelPinBtn) adCancelPinBtn.addEventListener('click', () => { stopAdPolling(); if (adPinPanel) adPinPanel.style.display = 'none'; });
            if (adSaveApiKeyBtn) adSaveApiKeyBtn.addEventListener('click', async () => {
                const apikey = (adApiKeyInput?.value || '').trim();
                if (!apikey) { showNotification('Enter an AllDebrid API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Logged in'; showNotification('AllDebrid API key saved'); adApiKeyInput.value=''; }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            });
            if (adClearApiKeyBtn) adClearApiKeyBtn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Not logged in'; showNotification('Logged out of AllDebrid'); }
                } catch {}
            });

            // TorBox: save/clear token
            if (tbSaveTokenBtn) tbSaveTokenBtn.addEventListener('click', async () => {
                const token = (tbTokenInput?.value || '').trim();
                if (!token) { showNotification('Enter a TorBox token'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Logged in'; tbTokenInput.value = ''; showNotification('TorBox token saved'); }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            });
            if (tbClearTokenBtn) tbClearTokenBtn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Not logged in'; showNotification('Logged out of TorBox'); }
                } catch {}
            });

            // Premiumize: save/clear API key
            if (pmSaveApiKeyBtn) pmSaveApiKeyBtn.addEventListener('click', async () => {
                const apikey = (pmApiKeyInput?.value || '').trim();
                if (!apikey) { showNotification('Enter a Premiumize API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Logged in'; pmApiKeyInput.value = ''; showNotification('Premiumize API key saved'); }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            });
            if (pmClearApiKeyBtn) pmClearApiKeyBtn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { if (debridStatus) debridStatus.textContent = 'Not logged in'; showNotification('Logged out of Premiumize'); }
                } catch {}
            });

            // Open Jackett installer link in default browser
            if (openJackettLinkBtn) {
                openJackettLinkBtn.addEventListener('click', async () => {
                    const url = 'https://github.com/Jackett/Jackett/releases/download/v0.24.124/Jackett.Installer.Windows.exe';
                    if (window.electronAPI?.openExternal) {
                        const res = await window.electronAPI.openExternal(url);
                        if (!res?.success) {
                            showNotification('Failed to open browser. Copying link to clipboard.');
                            try { await navigator.clipboard.writeText(url); } catch {}
                        }
                    } else {
                        // Fallback: copy link if preload is unavailable
                        showNotification('Copying link to clipboard. Open it in your browser.');
                        try { await navigator.clipboard.writeText(url); } catch {}
                    }
                });
            }
            
            // Close modals on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (settingsModal.classList.contains('active')) {
                        hideSettingsModal();
                    }
                    else if (apiSetupModal.classList.contains('active') && hasApiKey) {
                        hideApiSetupModal();
                    }
                }
            });
            
            // Enter key for API inputs
            firstTimeApiKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveFirstTimeApiKey_();
                }
            });
            
            newApiKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveSettings_();
                }
            });

            // Search input
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter' && searchInput.value.trim() !== '') {
                    e.preventDefault();
                    const query = searchInput.value.trim();
                    // Navigate to home for search to display results clearly
                    if (activeRoute !== 'home') {
                        window.location.hash = '#/';
                    }
                    await searchMovies(query);
                }
            });

            // Genres navigation
            genresBtn.addEventListener('click', () => {
                window.location.hash = '#/genres';
            });

            // My List navigation
            const myListBtn = document.getElementById('myListBtn');
            if (myListBtn) {
                myListBtn.addEventListener('click', () => {
                    window.location.hash = '#/my-list';
                });
            }

            // Done Watching navigation
            const doneWatchingBtn = document.getElementById('doneWatchingBtn');
            if (doneWatchingBtn) {
                doneWatchingBtn.addEventListener('click', () => {
                    window.location.hash = '#/done-watching';
                });
            }

            // Router: hash change
            window.addEventListener('hashchange', handleRoute);

            // Infinite scroll - handle both UI modes
            window.addEventListener('scroll', handleScroll);
            
            // Add scroll listener for NEW UI mode (scrolls inside main element)
            const appMainElement = document.querySelector('.app-main main');
            if (appMainElement) {
                appMainElement.addEventListener('scroll', handleScroll);
            }
            
            // Modal close
            modalClose.addEventListener('click', closeModal);
            
            // Player close
            closePlayerBtn.addEventListener('click', closePlayer);
            
            // Custom Player close
            closeCustomPlayer.addEventListener('click', closeCustomPlayer_);
            
            // Watch now button
            watchNowBtn.addEventListener('click', (e) => showTorrents(e));
            
            // Refresh torrents
            refreshTorrents.addEventListener('click', () => fetchTorrents());
            
            // MPV Controls
            // Resume modal elements
            const resumeModal = document.getElementById('resumeModal');
            const resumeClose = document.getElementById('resumeClose');
            const resumeTimeEl = document.getElementById('resumeTime');
            const resumeContinue = document.getElementById('resumeContinue');
            const resumeStartOver = document.getElementById('resumeStartOver');

            function formatResumeSeconds(s) { try { return formatTime(Math.floor(Number(s||0))); } catch(_) { return '00:00'; } }
            function hideResumeModal(){ resumeModal?.classList.remove('active'); }
            function showResumeModal(){ resumeModal?.classList.add('active'); }

            // Dismiss on outside click
            if (resumeModal) {
                resumeModal.addEventListener('click', (e) => {
                    if (e.target === resumeModal) {
                        hideResumeModal();
                    }
                });
                // prevent bubbling from content
                const rc = resumeModal.querySelector('.modal-content');
                if (rc) rc.addEventListener('click', (e) => e.stopPropagation());
            }

            async function handlePlayNowClick() {
                // Ensure we have latest resume info; fetch if not present
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res; // keep in sync
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    // Wire temp listeners
                    const onCont = async () => {
                        // Immediately persist current resume snapshot so a record exists right away
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        openCustomPlayer();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        // Reset local resume so player starts at 0
                        resumeInfo = null;
                        hideResumeModal();
                        openCustomPlayer();
                        // As soon as playback begins, record fresh progress so quitting early is remembered
                        try {
                            const onFirst = () => { try { saveResumeThrottled(true); } catch(_) {} customVideo.removeEventListener('timeupdate', onFirst); };
                            customVideo.addEventListener('timeupdate', onFirst);
                        } catch(_) {}
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                openCustomPlayer();
            }

            async function handleOpenMPVClick() {
                // Ensure we have latest resume info; fetch if not present
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res;
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    const onCont = async () => {
                        // Immediately persist current resume snapshot for MPV continue
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        resumeInfo = null; // start from 0
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                await openInMPV();
            }

            openMPVBtn.addEventListener('click', handleOpenMPVClick);
            copyStreamBtn.addEventListener('click', copyStreamUrl);
            playNowBtn.addEventListener('click', handlePlayNowClick);
            
            // Custom Player Controls
            playPauseBtn.addEventListener('click', togglePlayPause);
            rewindBtn.addEventListener('click', () => skipTime(-10));
            forwardBtn.addEventListener('click', () => skipTime(10));
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            progressBar.addEventListener('click', seekVideo);
            subtitleFile.addEventListener('change', handleSubtitleUpload);
            // HTML5 audio controls
            htmlVolume.addEventListener('input', () => { customVideo.volume = Math.max(0, Math.min(1, Number(htmlVolume.value) / 100)); });
            htmlMuteBtn.addEventListener('click', () => { customVideo.muted = !customVideo.muted; htmlMuteBtn.innerHTML = customVideo.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>'; });
            // HTML5 Subtitles menu
            htmlSubsBtn.addEventListener('click', () => {
                if (htmlSubsPanel.style.display === 'block') htmlSubsPanel.style.display = 'none';
                else { 
                    htmlSubsPanel.style.display = 'block'; 
                    fetchAndRenderHtmlSubs();
                    updateSubtitleControlDisplays();
                }
            });
            htmlSubsClose.addEventListener('click', () => htmlSubsPanel.style.display = 'none');
            
            // Subtitle customization controls
            if (htmlSubsUploadBtn && subtitleFile) {
                htmlSubsUploadBtn.addEventListener('click', () => subtitleFile.click());
            }
            
            if (subsSizeInput) {
                subsSizeInput.addEventListener('input', () => {
                    subtitleSettings.size = Number(subsSizeInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsColorInput) {
                subsColorInput.addEventListener('input', () => {
                    subtitleSettings.color = subsColorInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundInput) {
                subsBackgroundInput.addEventListener('input', () => {
                    subtitleSettings.background = subsBackgroundInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundOpacityInput) {
                subsBackgroundOpacityInput.addEventListener('input', () => {
                    subtitleSettings.backgroundOpacity = Number(subsBackgroundOpacityInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsFontSelect) {
                subsFontSelect.addEventListener('change', () => {
                    subtitleSettings.font = subsFontSelect.value;
                    applySubtitleSettings();
                });
            }
            
            // WCJS Controls
            closeWcjsPlayer.addEventListener('click', closeWCJSPlayer);
            wcjsPlayPauseBtn.addEventListener('click', wcjsTogglePlayPause);
            wcjsRewindBtn.addEventListener('click', () => wcjsSkipTime(-10));
            wcjsForwardBtn.addEventListener('click', () => wcjsSkipTime(10));
            wcjsFullscreenBtn.addEventListener('click', wcjsToggleFullscreen);
            wcjsProgressBar.addEventListener('click', wcjsSeek);
            wcjsMuteBtn.addEventListener('click', wcjsToggleMute);
            wcjsVolume.addEventListener('input', wcjsSetVolume);
            wcjsSubtitleFile.addEventListener('change', wcjsHandleSubtitleUpload);
            wcjsSubsBtn.addEventListener('click', () => {
                if (wcjsSubsPanel.style.display === 'block') wcjsSubsPanel.style.display = 'none';
                else { wcjsSubsPanel.style.display = 'block'; wcjsAudioPanel.style.display = 'none'; fetchAndRenderSubtitles(); }
            });
            wcjsAudioBtn.addEventListener('click', () => {
                if (wcjsAudioPanel.style.display === 'block') wcjsAudioPanel.style.display = 'none';
                else { wcjsAudioPanel.style.display = 'block'; wcjsSubsPanel.style.display = 'none'; renderAudioTracks(); }
            });
            wcjsSubsRefresh.addEventListener('click', fetchAndRenderSubtitles);
            wcjsSubsClose.addEventListener('click', () => wcjsSubsPanel.style.display = 'none');
            wcjsAudioClose.addEventListener('click', () => wcjsAudioPanel.style.display = 'none');
            
          
            customVideo.addEventListener('loadstart', () => {
                loadingOverlay.style.display = 'flex';
            });
            
            customVideo.addEventListener('canplay', () => {
                loadingOverlay.style.display = 'none';
            });
            
            customVideo.addEventListener('timeupdate', updateProgress);
            customVideo.addEventListener('loadedmetadata', updateDuration);
            customVideo.addEventListener('play', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
            });
            customVideo.addEventListener('pause', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            });
            
           
            detailsModal.addEventListener('click', (e) => {
                if (e.target === detailsModal) {
                    closeModal();
                }
            });
            
 

            customPlayerContainer.addEventListener('click', (e) => {
                if (e.target === customPlayerContainer) {
                    closeCustomPlayer_();
                }
            });

          
            wcjsPlayerContainer.addEventListener('click', (e) => {
                if (e.target === wcjsPlayerContainer) {
                    closeWCJSPlayer();
                }
            });

            // Close settings modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    hideSettingsModal();
                }
            });

            // Category filtering (home)
            document.querySelectorAll('.category').forEach(category => {
                category.addEventListener('click', () => {
                    document.querySelectorAll('.category').forEach(c => c.classList.remove('active'));
                    category.classList.add('active');
                    currentCategory = category.dataset.category;
                    moviesGrid.innerHTML = '';
                    currentPage = 1;
                    loadMovies(currentCategory);
                });
            });

            // Toggle buttons on genre details
            toggleMoviesBtn.addEventListener('click', () => {
                if (currentGenreType !== 'movie') {
                    setGenreType('movie');
                }
            });
            toggleTVBtn.addEventListener('click', () => {
                if (currentGenreType !== 'tv') {
                    setGenreType('tv');
                }
            });

            // Keyboard shortcuts for custom player
            document.addEventListener('keydown', (e) => {
                if (customPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            togglePlayPause();
                            break;
                        case 'ArrowRight':
                            skipTime(10);
                            break;
                        case 'ArrowLeft':
                            skipTime(-10);
                            break;
                        case 'KeyF':
                            toggleFullscreen();
                            break;
                        case 'Escape':
                            closeCustomPlayer_();
                            break;
                    }
                } else if (wcjsPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            wcjsTogglePlayPause();
                            break;
                        case 'ArrowRight':
                            wcjsSkipTime(10);
                            break;
                        case 'ArrowLeft':
                            wcjsSkipTime(-10);
                            break;
                        case 'KeyF':
                            wcjsToggleFullscreen();
                            break;
                        case 'Escape':
                            closeWCJSPlayer();
                            break;
                    }
                }
            });
            
            // Logo click handlers - navigate to home
            const sidebarLogo = document.getElementById('sidebarLogo');
            if (sidebarLogo) {
                sidebarLogo.addEventListener('click', () => {
                    window.location.href = 'http://localhost:3000';
                });
            }
            
            // Header logo click (for both OLD and NEW UI)
            const headerLogo = document.querySelector('.logo');
            if (headerLogo) {
                headerLogo.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.location.href = 'http://localhost:3000';
                });
            }
            
            // Sidebar navigation for new UI
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    const page = item.dataset.page;
                    sidebarNavItems.forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    
                    if (page === 'home') {
                        showHomePage();
                    } else if (page === 'genres') {
                        showGenresPage();
                    } else if (page === 'my-list') {
                        showMyListPage();
                    } else if (page === 'done-watching') {
                        showDoneWatchingPage();
                    }
                });
            });
            
            // Sidebar clear cache
            const sidebarClearCache = document.getElementById('sidebarClearCache');
            if (sidebarClearCache) {
                sidebarClearCache.addEventListener('click', async () => {
                    const result = await window.electronAPI.clearCache();
                    showNotification(result || 'Cache cleared!');
                });
            }
            
            // Sidebar settings
            const sidebarSettings = document.getElementById('sidebarSettings');
            if (sidebarSettings) {
                sidebarSettings.addEventListener('click', showSettingsModal);
            }
            
            // Quick refresh button
            const quickRefresh = document.getElementById('quickRefresh');
            if (quickRefresh) {
                quickRefresh.addEventListener('click', () => {
                    window.location.reload();
                });
            }
            
            // Sort and Filter buttons (NEW UI)
            const sortBtn = document.getElementById('sortBtn');
            const filterBtn = document.getElementById('filterBtn');
            if (sortBtn) {
                sortBtn.addEventListener('click', () => {
                    // Cycle through sort options
                    if (currentSort === 'popularity') {
                        currentSort = 'rating';
                        showNotification('Sorted by Rating ⭐');
                    } else if (currentSort === 'rating') {
                        currentSort = 'date';
                        showNotification('Sorted by Release Date 📅');
                    } else {
                        currentSort = 'popularity';
                        showNotification('Sorted by Popularity 🔥');
                    }
                    refreshDisplay();
                });
            }
            if (filterBtn) {
                filterBtn.addEventListener('click', () => {
                    // Cycle through filter options
                    if (currentFilter === 'all') {
                        currentFilter = 'hd';
                        showNotification('Filter: HD Quality (7+ rating) 🎬');
                    } else if (currentFilter === 'hd') {
                        currentFilter = '4k';
                        showNotification('Filter: 4K Quality (8+ rating) ✨');
                    } else {
                        currentFilter = 'all';
                        showNotification('Filter: All Content 📺');
                    }
                    refreshDisplay();
                });
            }
        }

        // Router handler
        async function handleRoute() {
            const hash = window.location.hash || '#/';
            // Default route
            if (hash === '#/' || hash === '#') {
                activeRoute = 'home';
                showSection('home');
                // Load home content if first time or if grid empty
                if (moviesGrid.children.length === 0) {
                    currentPage = 1;
                    moviesGrid.innerHTML = '';
                    await loadMovies(currentCategory);
                }
                return;
            }

            if (hash.startsWith('#/genre/')) {
    const genreName = decodeURIComponent(hash.slice('#/genre/'.length)).trim();
    activeRoute = 'genreDetails';
    showSection('genreDetails');
    await ensureGenresLoaded();
    await openGenreDetails(genreName);
    return;
} else if (hash === '#/genres') {
    activeRoute = 'genres';
    showSection('genres');
    await ensureGenresLoaded();
    renderGenres();
    return;
} else if (hash === '#/my-list') {
    activeRoute = 'my-list';
    showSection('my-list');
    await displayMyList();
    return;
} else if (hash === '#/done-watching') {
    activeRoute = 'done-watching';
    showSection('done-watching');
    await displayDoneWatching();
    return;
}

            // Fallback
            activeRoute = 'home';
            showSection('home');
        }

        function showSection(section) {
            // Reset basic visibility
            homePageEl.style.display = section === 'home' ? '' : 'none';
            genresPageEl.style.display = section === 'genres' ? '' : 'none';
            genreDetailsPageEl.style.display = section === 'genreDetails' ? '' : 'none';
            const myListPageEl = document.getElementById('myListPage');
            if (myListPageEl) myListPageEl.style.display = section === 'my-list' ? '' : 'none';
            const doneWatchingPageEl = document.getElementById('doneWatchingPage');
            if (doneWatchingPageEl) doneWatchingPageEl.style.display = section === 'done-watching' ? '' : 'none';
            // Update navigation states
            updateNavigationStates(section);
            // Reset loading flag for new route
            isLoading = false;
            // Scroll to top on route change
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function updateNavigationStates(activeSection) {
            // Update sidebar navigation (new UI)
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === activeSection || 
                    (activeSection === 'genreDetails' && item.dataset.page === 'genres')) {
                    item.classList.add('active');
                }
            });

            // Update header buttons (classic UI)
            const headerButtons = {
                'home': null, // No specific home button
                'genres': document.getElementById('genresBtn'),
                'my-list': document.getElementById('myListBtn'),
                'done-watching': document.getElementById('doneWatchingBtn')
            };

            // Reset all header button active states
            Object.values(headerButtons).forEach(btn => {
                if (btn) btn.classList.remove('active');
            });

            // Set active header button
            const activeBtn = headerButtons[activeSection];
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        async function ensureGenresLoaded() {
            if (genresLoaded) return;
            try {
                genresLoading.style.display = 'block';
                // Fetch movie and tv genres
                const [movieRes, tvRes] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}`),
                    fetch(`https://api.themoviedb.org/3/genre/tv/list?api_key=${TMDB_API_KEY}`)
                ]);
                const [movieData, tvData] = await Promise.all([movieRes.json(), tvRes.json()]);
                const map = new Map();
                (movieData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    map.set(key, { name: g.name, movieId: g.id, tvId: null });
                });
                (tvData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    if (map.has(key)) {
                        map.get(key).tvId = g.id;
                    } else {
                        map.set(key, { name: g.name, movieId: null, tvId: g.id });
                    }
                });
                genresMap = map;
                genresLoaded = true;
            } catch (e) {
                console.error('Error loading genres:', e);
            } finally {
                genresLoading.style.display = 'none';
            }
        }

        function renderGenres() {
            genresGrid.innerHTML = '';
            const entries = Array.from(genresMap.values()).sort((a, b) => a.name.localeCompare(b.name));
            entries.forEach(g => {
                const card = document.createElement('div');
                card.className = 'genre-card';
                card.innerHTML = `
                    <div class="genre-info">
                        <div class="genre-title">${g.name}</div>
                        <div class="genre-availability">
                            ${g.movieId ? '<span class="genre-chip"><i class="fas fa-film"></i> Movie</span>' : ''}
                            ${g.tvId ? '<span class="genre-chip"><i class="fas fa-tv"></i> TV</span>' : ''}
                        </div>
                    </div>
                `;
                card.addEventListener('click', () => {
                    window.location.hash = `#/genre/${encodeURIComponent(g.name)}`;
                });
                genresGrid.appendChild(card);
            });
        }

        function setGenreToggleActive() {
            toggleMoviesBtn.classList.toggle('active', currentGenreType === 'movie');
            toggleTVBtn.classList.toggle('active', currentGenreType === 'tv');
        }

        async function openGenreDetails(genreName) {
            const key = genreName.toLowerCase();
            currentGenre = genresMap.get(key);
            if (!currentGenre) {
                // If genre map not found (edge case), reload genres and try again
                await ensureGenresLoaded();
                currentGenre = genresMap.get(key);
            }
            if (!currentGenre) {
                genreTitleEl.textContent = genreName;
                genreResultsGrid.innerHTML = '';
                genreEmptyMessage.style.display = 'block';
                return;
            }

            genreTitleEl.textContent = currentGenre.name;

            // Default type preference: movie if available, else tv
            currentGenreType = currentGenre.movieId ? 'movie' : 'tv';
            setGenreToggleActive();

            // Reset results grid
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;

            await loadGenreItems();
        }

        function setGenreType(type) {
            currentGenreType = type;
            setGenreToggleActive();
            // Reset and reload
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;
            isLoading = false;
            loadGenreItems();
        }

        async function loadGenreItems() {
            if (isLoading) return;
            const genreId = currentGenreType === 'movie' ? currentGenre.movieId : currentGenre.tvId;
            if (!genreId) {
                genreEmptyMessage.style.display = 'block';
                return;
            }
            isLoading = true;
            genreLoadingIndicator.style.display = 'block';
            try {
                const url = `https://api.themoviedb.org/3/discover/${currentGenreType}?api_key=${TMDB_API_KEY}&with_genres=${genreId}&sort_by=popularity.desc&page=${genreCurrentPage}`;
                const res = await fetch(url);
                const data = await res.json();
                const items = data.results || [];
                if (genreCurrentPage === 1 && items.length === 0) {
                    genreEmptyMessage.style.display = 'block';
                } else {
                    displayGenreItems(items, currentGenreType);
                    genreCurrentPage++;
                }
            } catch (e) {
                console.error('Error loading genre items:', e);
            } finally {
                isLoading = false;
                genreLoadingIndicator.style.display = 'none';
            }
        }

        function displayGenreItems(items, mediaType) {
            items.forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                const title = item.title || item.name || 'Untitled';
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const rating = (item.vote_average || 0).toFixed(1);
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="done-watching-btn" onclick="toggleDoneWatching(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-check"></i>
                    </button>
                    <img src="https://image.tmdb.org/t/p/w500${item.poster_path}" alt="${title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${title}</h3>
                        <p class="movie-year">${year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${rating}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                genreResultsGrid.appendChild(card);
            });
        }

        // Load movies from TMDB (home)
        async function loadMovies(category = 'all') {
            if (isLoading) return;
            isLoading = true;
            loadingIndicator.style.display = 'block';
            
            // Reset cache if it's the first page
            if (currentPage === 1) {
                allMoviesCache = [];
            }
            
            // Reset page title to Trending Now
            const homePageIcon = document.getElementById('homePageIcon');
            const homePageText = document.getElementById('homePageText');
            if (homePageIcon && homePageText) {
                homePageIcon.className = 'fas fa-fire';
                homePageText.textContent = 'Trending Now';
            }

            try {
                let url;
                if (category === 'all') {
                    url = `https://api.themoviedb.org/3/trending/all/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                } else {
                    url = `https://api.themoviedb.org/3/trending/${category}/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                }
                const response = await fetch(url);
                const data = await response.json();
                displayMovies(data.results, currentPage > 1);
                currentPage++;
            } catch (error) {
                console.error('Error fetching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Search for movies and shows
        async function searchMovies(query) {
            if (isLoading) return;
            isLoading = true;
            moviesGrid.innerHTML = '';
            loadingIndicator.style.display = 'block';
            
            // Update page title for search
            const homePageIcon = document.getElementById('homePageIcon');
            const homePageText = document.getElementById('homePageText');
            if (homePageIcon && homePageText) {
                homePageIcon.className = 'fas fa-search';
                homePageText.textContent = `Search Results for "${query}"`;
            }

            try {
                const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1`);
                const data = await response.json();
                displayMovies(data.results);
            } catch (error) {
                console.error('Error searching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Display movies in the grid
        function displayMovies(movies, append = true) {
            // Cache movies for sorting/filtering
            if (!append) {
                allMoviesCache = [...movies];
            } else {
                allMoviesCache = [...allMoviesCache, ...movies];
            }
            
            // Apply current sort and filter
            let filteredMovies = applySortAndFilter([...movies]);
            
            filteredMovies.forEach(movie => {
                if (!movie.poster_path) return;

                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = movie.vote_average || 0;
                card.dataset.date = movie.release_date || movie.first_air_date || '';
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${movie.id}, '${movie.media_type || 'movie'}', '${(movie.title || movie.name || '').replace(/'/g, "\\'")}', '${movie.poster_path}', '${(movie.release_date || movie.first_air_date || '').substring(0, 4)}', ${movie.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="done-watching-btn" onclick="toggleDoneWatching(event, ${movie.id}, '${movie.media_type || 'movie'}', '${(movie.title || movie.name || '').replace(/'/g, "\\'")}', '${movie.poster_path}', '${(movie.release_date || movie.first_air_date || '').substring(0, 4)}', ${movie.vote_average || 0})">
                        <i class="fas fa-check"></i>
                    </button>
                    <img src="https://image.tmdb.org/t/p/w500${movie.poster_path}" alt="${movie.title || movie.name}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${movie.title || movie.name}</h3>
                        <p class="movie-year">${(movie.release_date || movie.first_air_date || '').substring(0, 4)}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(movie.vote_average || 0).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(movie, movie.media_type || null));
                moviesGrid.appendChild(card);
            });
        }
        
        // Apply sort and filter to movies
        function applySortAndFilter(movies) {
            let filtered = [...movies];
            
            // Apply filter
            if (currentFilter === 'hd') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 7);
            } else if (currentFilter === '4k') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 8);
            }
            
            // Apply sort
            if (currentSort === 'rating') {
                filtered.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));
            } else if (currentSort === 'date') {
                filtered.sort((a, b) => {
                    const dateA = new Date(a.release_date || a.first_air_date || 0);
                    const dateB = new Date(b.release_date || b.first_air_date || 0);
                    return dateB - dateA;
                });
            }
            // popularity is default (no sorting needed as TMDB returns sorted by popularity)
            
            return filtered;
        }
        
        // Refresh display with current sort/filter
        function refreshDisplay() {
            moviesGrid.innerHTML = '';
            displayMovies(allMoviesCache, false);
        }

        // Handle infinite scroll - route aware
        function handleScroll(e) {
            let shouldLoad = false;
            
            // Check if we're in NEW UI mode (scrolling inside main element)
            if (document.body.classList.contains('ui-new')) {
                const mainElement = document.querySelector('.app-main main');
                if (mainElement && e && e.target === mainElement) {
                    const scrollTop = mainElement.scrollTop;
                    const scrollHeight = mainElement.scrollHeight;
                    const clientHeight = mainElement.clientHeight;
                    shouldLoad = scrollTop + clientHeight >= scrollHeight - 500 && !isLoading;
                }
            } else {
                // OLD UI mode (scrolling on window)
                shouldLoad = window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading;
            }
            
            if (shouldLoad) {
                if (activeRoute === 'home') {
                    loadMovies(currentCategory);
                } else if (activeRoute === 'genreDetails') {
                    loadGenreItems();
                }
            }
        }

        // Open details modal (accept optional forced type)
        async function openDetailsModal(movie, forcedType = null) {
            currentContent = movie;
            // Determine media type
            if (forcedType) {
                currentMediaType = forcedType === 'tv' ? 'tv' : 'movie';
            } else {
                if (movie.media_type) {
                    currentMediaType = movie.media_type === 'tv' ? 'tv' : 'movie';
                } else {
                    // Infer by presence of 'name' vs 'title'
                    currentMediaType = movie.name && !movie.title ? 'tv' : 'movie';
                }
            }
            torrentsLoaded = false;
            torrentsContainer.style.display = 'none';
            torrentsList.innerHTML = '';

            modalBackdrop.src = `https://image.tmdb.org/t/p/w1280${movie.backdrop_path || movie.poster_path || ''}`;
            modalPoster.src = `https://image.tmdb.org/t/p/w500${movie.poster_path || movie.backdrop_path || ''}`;
            modalTitle.textContent = movie.title || movie.name || 'Untitled';
            modalRating.textContent = Number(movie.vote_average || 0).toFixed(1);
            modalYear.textContent = (movie.release_date || movie.first_air_date || '').substring(0, 4);
            modalOverview.textContent = movie.overview || '';

            // Fetch additional details
            const detailsUrl = `https://api.themoviedb.org/3/${currentMediaType}/${movie.id}?api_key=${TMDB_API_KEY}&append_to_response=credits,similar`;
            try {
                const response = await fetch(detailsUrl);
                const details = await response.json();
                modalRuntime.textContent = details.runtime ? `${details.runtime} min` : (details.episode_run_time && details.episode_run_time.length ? `${details.episode_run_time[0]} min` : '');
                modalTagline.textContent = details.tagline || '';
                displayCast(details.credits?.cast || []);
                displaySimilar(details.similar?.results || [], currentMediaType);

                if (currentMediaType === 'tv') {
                    seasonsContainer.style.display = 'block';
                    displaySeasons(details.seasons || []);
                    // Load episodes for the first usable season by default
                    const firstSeason = (details.seasons || []).find(s => s.season_number !== 0);
                    if (firstSeason) {
                        currentSeason = firstSeason.season_number;
                        loadEpisodes(firstSeason.season_number);
                    }
                } else {
                    seasonsContainer.style.display = 'none';
                }

            } catch (error) {
                console.error('Error fetching details:', error);
            }

            detailsModal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Close details modal
        function closeModal() {
            detailsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // Display cast
        function displayCast(cast) {
            castGrid.innerHTML = '';
            (cast || []).slice(0, 10).forEach(member => {
                const card = document.createElement('div');
                card.className = 'cast-card';
                card.innerHTML = `
                    <img src="${member.profile_path ? `https://image.tmdb.org/t/p/w185${member.profile_path}` : 'https://via.placeholder.com/185x278'}" alt="${member.name}" class="cast-img">
                    <p class="cast-name">${member.name}</p>
                    <p class="cast-character">${member.character || ''}</p>
                `;
                castGrid.appendChild(card);
            });
        }

        // Display similar content (force the same media type for correct behavior)
        function displaySimilar(similar, mediaType) {
            similarGrid.innerHTML = '';
            (similar || []).slice(0, 6).forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.innerHTML = `
                    <img src="https://image.tmdb.org/t/p/w300${item.poster_path}" alt="${item.title || item.name}" class="movie-poster" style="height: 225px;">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title || item.name}</h3>
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                similarGrid.appendChild(card);
            });
        }

        // Display seasons for TV shows
        function displaySeasons(seasons) {
            seasonSelector.innerHTML = '';
            seasons.forEach(season => {
                if (season.season_number === 0) return; // Skip specials
                const btn = document.createElement('button');
                btn.className = 'season-btn';
                btn.textContent = season.name;
                btn.dataset.seasonNumber = season.season_number;
                if (season.season_number === currentSeason) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    currentSeason = season.season_number;
                    document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadEpisodes(currentSeason);
                    torrentsContainer.style.display = 'block'; // Make torrents visible
                    fetchTorrents(currentSeason);
                });
                seasonSelector.appendChild(btn);
            });
        }

        // Load episodes for a season
        async function loadEpisodes(seasonNumber) {
            episodesGrid.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i></div>';
            try {
                const response = await fetch(`https://api.themoviedb.org/3/tv/${currentContent.id}/season/${seasonNumber}?api_key=${TMDB_API_KEY}`);
                const data = await response.json();
                displayEpisodes(data.episodes || []);
            } catch (error) {
                console.error(`Error fetching episodes for season ${seasonNumber}:`, error);
            }
        }

        // Display episodes
        function displayEpisodes(episodes) {
            episodesGrid.innerHTML = '';
            episodes.forEach(episode => {
                const card = document.createElement('div');
                card.className = 'episode-card';
                card.innerHTML = `
                    <img src="${episode.still_path ? `https://image.tmdb.org/t/p/w300${episode.still_path}` : 'https://via.placeholder.com/300x169'}" alt="${episode.name}" class="episode-img">
                    <div class="episode-info">
                        <h4 class="episode-title">E${episode.episode_number}: ${episode.name}</h4>
                        <p class="episode-date">${episode.air_date || ''}</p>
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    document.querySelectorAll('.episode-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    showTorrents(e, currentSeason, episode.episode_number);
                });
                episodesGrid.appendChild(card);
            });
        }

        // Show torrents for the current content
        function showTorrents(event, season = null, episode = null) {
            if (!hasApiKey && !useTorrentless) {
                showApiSetupModal();
                return;
            }
            torrentsContainer.style.display = 'block';
            // Reset loaded state for new searches
            torrentsLoaded = false;
            fetchTorrents(season, episode);
        }

        // Fetch torrents from the backend
        async function fetchTorrents(season = null, episode = null) {
            if (!currentContent) return;

            let query = currentContent.title || currentContent.name;
            if (currentMediaType === 'movie') {
                const year = (currentContent.release_date || '').substring(0, 4);
                if (year) {
                    query = `${query} ${year}`;
                }
            } else if (currentMediaType === 'tv') {
                if (season && episode) {
                    const seasonStr = String(season).padStart(2, '0');
                    const episodeStr = String(episode).padStart(2, '0');
                    query = `${query} S${seasonStr}.E${episodeStr}`;
                } else if (season) {
                    const seasonStr = String(season).padStart(2, '0');
                    query = `${query} S${seasonStr}`;
                }
            }

            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching...</div>';
            torrentsLoaded = true;

            try {
                const response = await fetch(`${API_BASE_URL}/torrents?q=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const torrents = await response.json();
                displayTorrents(torrents);
            } catch (error) {
                console.error('Error fetching torrents:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> ${error.message}</div>`;
            }
        }

        // Display torrents
        function displayTorrents(torrents) {
            allTorrents = (torrents || []).sort((a, b) => b.seeders - a.seeders);
            torrentsPage = 1;
            renderTorrentsPage();
        }

        function renderTorrentsPage() {
            torrentsList.innerHTML = '';
            if (allTorrents.length === 0) {
                torrentsList.innerHTML = '<p>No torrents found.</p>';
                return;
            }

            const start = (torrentsPage - 1) * torrentsPerPage;
            const end = start + torrentsPerPage;
            const paginatedTorrents = allTorrents.slice(start, end);

            let rdAvailChecked = 0;
            const rdAvailBudget = 12; // cap RD availability checks per render
            paginatedTorrents.forEach(torrent => {
                const item = document.createElement('div');
                item.className = 'torrent-item';
                item.innerHTML = `
                    <div class="torrent-info">
                        <p class="torrent-name">${torrent.title}</p>
                        <div class="torrent-details">
                            <span><i class="fas fa-arrow-up"></i> ${torrent.seeders}</span>
                            <span><i class="fas fa-database"></i> ${((torrent.size || 0) / 1024 / 1024 / 1024).toFixed(2)} GB</span>
                            <span class="cached-badge" style="display:none; background:#198754; color:#fff; padding:2px 6px; border-radius:4px; font-size: 0.8rem; margin-left:8px;">Cached</span>
                        </div>
                    </div>
                    <div class="torrent-actions">
                        <button class="btn-play torrent-btn"><i class="fas fa-play"></i> Play</button>
                        <button class="btn-copy torrent-btn"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                `;

                item.querySelector('.btn-play').addEventListener('click', () => startStream(torrent.magnet));
                item.querySelector('.btn-copy').addEventListener('click', () => copyMagnet(torrent.magnet));
                torrentsList.appendChild(item);

                // Debrid availability badge (RD only)
                if (useDebrid && debridAuth && debridProvider === 'realdebrid' && torrent.magnet && rdAvailChecked < rdAvailBudget) {
                    const btih = extractInfoHashFromMagnet(torrent.magnet);
                    if (btih) {
                        (async () => {
                            try {
                                const r = await fetch(`${API_BASE_URL}/debrid/availability?btih=${btih}`);
                                if (r.ok) {
                                    const j = await r.json();
                                    if (j && j.available) {
                                        const b = item.querySelector('.cached-badge');
                                        if (b) b.style.display = 'inline-block';
                                    }
                                } else {
                                    // If RD rate limits or endpoint disabled, stop further checks on this page render
                                    try {
                                        const txt = await r.text();
                                        if (/RD_RATE_LIMIT|too_many_requests/i.test(txt)) {
                                            console.warn('[UI][Debrid] availability paused due to rate limit');
                                        }
                                        if (/RD_FEATURE_UNAVAILABLE|disabled_endpoint/i.test(txt)) {
                                            console.warn('[UI][Debrid] availability disabled for this account');
                                        }
                                    } catch {}
                                }
                            } catch(_) {}
                        })();
                        rdAvailChecked++;
                    }
                }
            });

            renderTorrentPagination();
        }

        function renderTorrentPagination() {
            const totalPages = Math.ceil(allTorrents.length / torrentsPerPage);
            if (totalPages <= 1) {
                return;
            }

            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'torrent-pagination';

            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = '<i class="fas fa-arrow-left"></i>';
            prevBtn.disabled = torrentsPage === 1;
            prevBtn.addEventListener('click', () => {
                if (torrentsPage > 1) {
                    torrentsPage--;
                    renderTorrentsPage();
                }
            });

            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = '<i class="fas fa-arrow-right"></i>';
            nextBtn.disabled = torrentsPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (torrentsPage < totalPages) {
                    torrentsPage++;
                    renderTorrentsPage();
                }
            });

            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Page ${torrentsPage} of ${totalPages}`;

            paginationContainer.appendChild(prevBtn);
            paginationContainer.appendChild(pageInfo);
            paginationContainer.appendChild(nextBtn);

            torrentsList.appendChild(paginationContainer);
        }

        // Start streaming a torrent
        async function startStream(magnet) {
            // Refresh debrid flags before deciding path
            await ensureDebridState();
            const providerLabel = getProviderDisplayName(debridProvider);
            // If Debrid is enabled but not authenticated, block fallback and prompt login
            if (useDebrid && !debridAuth) {
                console.warn('[UI][Debrid] blocked: enabled but not logged in');
                showNotification(`${providerLabel} is enabled but you are not logged in. Please log in to continue.`);
                promptDebridLogin();
                return;
            }
            // Debrid-exclusive flow when enabled: skip WebTorrent entirely
            if (useDebrid && debridAuth && magnet && magnet.startsWith('magnet:')) {
                try {
                    // Open our player UI first
                    showPlayer();
                    mpvLoading.style.display = 'flex';
                    mpvControls.style.display = 'none';
                    fileList.innerHTML = '';
                    subtitleList.innerHTML = '';
                    subtitleControls.style.display = 'none';
                    playerTitle.textContent = `Preparing ${providerLabel}…`;

                    // Add magnet to RD and select all
                    console.log('[UI][Debrid] prepare addMagnet');
                    const prep = await fetch(`${API_BASE_URL}/debrid/prepare`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ magnet })
                    });
                    if (!prep.ok) {
                        let notif = 'Debrid prepare failed';
                        try {
                            const txt = await prep.text();
                            console.error('[UI][Debrid] prepare failed', txt);
                            try {
                                const ej = JSON.parse(txt);
                                if (ej && ej.code === 'RD_PREMIUM_REQUIRED') {
                                    notif = `${providerLabel} premium is required to add torrents. Disable Debrid in Settings to use WebTorrent instead.`;
                                } else if (ej && ej.code === 'DEBRID_UNAUTH') {
                                    notif = `${providerLabel} authentication invalid. Please login again.`;
                                    if (debridStatus) debridStatus.textContent = 'Not logged in';
                                    promptDebridLogin();
                                } else if (ej && ej.code === 'TORBOX_UNIMPLEMENTED') {
                                    notif = 'TorBox is not supported yet. Please switch provider in Settings or disable Debrid to use WebTorrent.';
                                } else if (ej && ej.error) {
                                    notif = ej.error;
                                }
                            } catch { /* not json */ }
                        } catch { /* ignore */ }
                        showNotification(notif);
                        return;
                    }
                    const prepj = await prep.json();
                    const rdId = prepj.id;
                    let info = prepj.info || null;
                    if (!info || !Array.isArray(info.files) || !info.files.length) {
                        await new Promise(r => setTimeout(r, 900));
                        const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                        if (fres.ok) info = await fres.json();
                    }

                    let files = (info && info.files) || [];
                    // If metadata/files are not ready yet, poll a few times (helps TorBox and slow RD responses)
                    if (!files.length) {
                        for (let i = 0; i < 8; i++) {
                            await new Promise(r => setTimeout(r, 1000));
                            try {
                                const rf = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                                if (rf.ok) {
                                    const ij = await rf.json();
                                    files = (ij && ij.files) || [];
                                    if (files.length) break;
                                }
                            } catch {}
                        }
                    }
                    // Render RD files for explicit selection, like our torrent file list
                    mpvLoading.style.display = 'none';
                    fileList.innerHTML = '';
                    playerTitle.textContent = info?.filename || providerLabel;
                    const rdVideos = files.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                    const rdSubs = files.filter(f => /\.(srt|vtt)$/i.test(f.path || f.filename || ''));

                    const displayName = (f) => (f.path || f.filename || 'file');
                    const displaySize = (f) => ((f.bytes || f.size || 0) / 1024 / 1024).toFixed(2) + ' MB';

                    // Helper to render a small cached status badge
                    const statusBadgeHtml = (file) => {
                        const cached = Array.isArray(file.links) && file.links.length > 0;
                        const label = cached ? 'Cached' : 'Not cached';
                        const bg = cached ? 'background:#198754;' : 'background:#6c757d;';
                        return `<span class="source-badge rd-cache-badge" style="${bg} margin-left:6px;">${label}</span>`;
                    };

                    // Poll Debrid files info until the specific file has links (cached) or timeout
                    async function waitForRdLinks(id, fileId, { timeoutMs = 30000, intervalMs = 1500 } = {}) {
                        const start = Date.now();
                        while (Date.now() - start < timeoutMs) {
                            try {
                                const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(id)}`);
                                if (!fres.ok) {
                                    // If rate limited or disabled endpoint reported, stop trying
                                    try {
                                        const t = await fres.text();
                                        if (/RD_RATE_LIMIT|RD_FEATURE_UNAVAILABLE/i.test(t)) return null;
                                    } catch {}
                                    await new Promise(r => setTimeout(r, intervalMs));
                                    continue;
                                }
                                const info = await fres.json();
                                const list = Array.isArray(info?.files) ? info.files : [];
                                const found = list.find(x => String(x.id || x.file) === String(fileId));
                                if (found && Array.isArray(found.links) && found.links.length) {
                                    return found.links[0];
                                }
                            } catch {}
                            await new Promise(r => setTimeout(r, intervalMs));
                        }
                        return null; // timed out
                    }

                    rdVideos.forEach((f) => {
                        const item = document.createElement('div');
                        item.className = 'file-item';
                        item.innerHTML = `<p class="file-name">${displayName(f)} ${statusBadgeHtml(f)}</p><p class="file-size">(${displaySize(f)})</p>`;
                        item.addEventListener('click', async () => {
                            try {
                                // Set resume key and prefetch resume info for Debrid path
                                try {
                                    const fileId = String(f.id || f.file || f.filename || f.path || '0');
                                    resumeKey = `debrid:${debridProvider}:${rdId}:${fileId}`;
                                    resumeInfo = await fetchResume(resumeKey);
                                } catch(_) {}
                                // Ensure only this file is selected for RD to process
                                try {
                                    console.log('[UI][Debrid] select-files', { id: rdId, file: String(f.id || f.file) });
                                    await fetch(`${API_BASE_URL}/debrid/select-files`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: rdId, files: String(f.id || f.file) }) });
                                } catch(e) { console.warn('[UI][Debrid] select-files failed', e?.message); }
                                // Find current link if already cached, else wait for caching
                                let link = Array.isArray(f.links) && f.links.length ? f.links[0] : null;
                                if (!link) {
                                    showNotification(`Not cached yet on ${providerLabel}. Waiting to cache…`);
                                    // Show loading indicator while waiting
                                    mpvLoading.style.display = 'flex';
                                    const waited = await waitForRdLinks(rdId, (f.id || f.file));
                                    link = waited;
                                    // Update badge to Cached if now available
                                    if (link) {
                                        try {
                                            const badge = item.querySelector('.rd-cache-badge');
                                            if (badge) { badge.textContent = 'Cached'; badge.style.background = '#198754'; }
                                        } catch {}
                                    }
                                }
                                if (!link) {
                                    showNotification('Still not cached. Try again later or disable Debrid in Settings to use WebTorrent.');
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                // Unrestrict the resolved link
                                const unres = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link }) });
                                if (!unres.ok) {
                                    console.error('[UI][Debrid] unrestrict/stream resolve failed', await unres.text());
                                    const msg = (debridProvider === 'torbox') ? 'Failed to get stream link' : 'Failed to unrestrict';
                                    showNotification(msg);
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                const uj = await unres.json();
                                if (!uj?.url) { console.error('[UI][Debrid] unrestrict response missing url', uj); showNotification('Invalid Debrid URL'); mpvLoading.style.display = 'none'; return; }
                                currentStreamUrl = `${API_BASE_URL}/stream/debrid?url=${encodeURIComponent(uj.url)}`;
                                const fname = baseName(f.path || f.filename || '');
                                currentSelectedVideoName = fname || displayName(f);
                                playerTitle.textContent = currentSelectedVideoName || displayName(f);
                                // Source badges -> Debrid
                                if (streamSourceBadge) { streamSourceBadge.textContent = 'Debrid'; streamSourceBadge.classList.remove('webtorrent'); streamSourceBadge.classList.add('debrid'); }
                                if (customSourceBadge) { customSourceBadge.textContent = 'Debrid'; customSourceBadge.classList.remove('webtorrent'); customSourceBadge.classList.add('debrid'); }
                                mpvControls.style.display = 'flex';
                                mpvLoading.style.display = 'none';
                                showNotification(`Ready via ${providerLabel}`);

                                // Auto-attach subtitle: prefer same folder subtitle
                                const sub = rdSubs[0];
                                if (sub && Array.isArray(sub.links) && sub.links.length) {
                                    try {
                                        const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: sub.links[0] }) });
                                        if (su.ok) {
                                            const suj = await su.json();
                                            if (suj?.url) {
                                                const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(sub) }) });
                                                const dlj = await dl.json();
                                                if (dl.ok && dlj.url) currentSubtitleUrl = dlj.url;
                                            }
                                        } else { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); }
                                    } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                                }
                            } catch (_) {
                                console.error('[UI][Debrid] file play failed');
                                showNotification('Failed to prepare Debrid file');
                            }
                        });
                        fileList.appendChild(item);
                    });

                    // Subtitle sidebar for visibility
                    if (rdSubs.length) {
                        subtitleControls.style.display = 'flex';
                        subtitleList.innerHTML = '';
                        subtitleList.classList.add('subtitle-list');
                        currentSubtitles = rdSubs.map(s => ({ name: displayName(s), index: -1 }));
                        rdSubs.forEach((s) => {
                            const subItem = document.createElement('div');
                            subItem.className = 'subtitle-item';
                            const langDiv = document.createElement('div');
                            langDiv.className = 'subtitle-lang';
                            langDiv.textContent = displayName(s);
                            subItem.appendChild(langDiv);
                            subItem.addEventListener('click', async () => {
                                try {
                                    const l = Array.isArray(s.links) && s.links.length ? s.links[0] : null;
                                    if (!l) return;
                                    const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: l }) });
                                    if (!su.ok) { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); return; }
                                    const suj = await su.json();
                                    if (!suj?.url) return;
                                    const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(s) }) });
                                    const dlj = await dl.json();
                                    if (dl.ok && dlj.url) {
                                        currentSubtitleUrl = dlj.url;
                                        showNotification('Subtitle ready');
                                    }
                                } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                            });
                            subtitleList.appendChild(subItem);
                        });
                    }
                    return; // Debrid path handled fully
                } catch (e) {
                    console.error('[UI][Debrid] flow failed', e?.message);
                    showNotification('Debrid path failed');
                    return;
                }
            }

            // Fallback only if Debrid is not enabled
            showPlayer();
            mpvLoading.style.display = 'flex';
            mpvControls.style.display = 'none';
            fileList.innerHTML = '';
            subtitleList.innerHTML = '';
            subtitleControls.style.display = 'none';
            playerTitle.textContent = 'Loading torrent info...';
            mpvLoading.style.display = 'flex';
            mpvControls.style.display = 'none';
            fileList.innerHTML = '';
            subtitleList.innerHTML = '';
            subtitleControls.style.display = 'none';
            playerTitle.textContent = 'Loading torrent info...';

            try {
                const response = await fetch(`${API_BASE_URL}/torrent-files?magnet=${encodeURIComponent(magnet)}`);
                const data = await response.json();
                currentTorrentData = data;
                playerTitle.textContent = data.name || 'Selected Torrent'; // Update title with torrent name
                displayFiles(data.videoFiles || [], data.subtitleFiles || []);
                // Set source badges to WebTorrent for this path
                if (streamSourceBadge) { streamSourceBadge.textContent = 'WebTorrent'; streamSourceBadge.classList.remove('debrid'); streamSourceBadge.classList.add('webtorrent'); }
                if (customSourceBadge) { customSourceBadge.textContent = 'WebTorrent'; customSourceBadge.classList.remove('debrid'); customSourceBadge.classList.add('webtorrent'); }
            } catch (error) {
                console.error('Error getting torrent files:', error);
                
            }
        }

        function promptDebridLogin() {
            try {
                showSettingsModal().then(() => {
                    setTimeout(() => {
                        try {
                            const sec = document.getElementById('debridSection');
                            if (sec && typeof sec.scrollIntoView === 'function') {
                                sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                            // Focus appropriate control by provider
                            if (debridProvider === 'alldebrid') {
                                if (adSection) adSection.style.display = '';
                                if (adStartPinBtn) adStartPinBtn.focus();
                            } else {
                                const input = document.getElementById('rdClientId');
                                if (input) input.focus();
                            }
                        } catch(_) {}
                    }, 50);
                });
            } catch(_) {
                // As a fallback, open settings without smooth behaviors
                showSettingsModal();
            }
        }

        // Helpers: parse BTIH from magnet and pick best file from RD
        function extractInfoHashFromMagnet(magnet) {
            try {
                const m = /btih:([A-Za-z0-9]{32,40})/i.exec(magnet);
                return m ? encodeURIComponent(m[1].toUpperCase()) : '';
            } catch { return ''; }
        }
        function pickBestVideoFile(files) {
            try {
                const vids = (files || []).filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                if (!vids.length) return null;
                vids.sort((a,b) => (b.bytes || b.size || 0) - (a.bytes || a.size || 0));
                return vids[0];
            } catch { return null; }
        }

        // Display files for selection
        function displayFiles(videos, subtitles) {
            mpvLoading.style.display = 'none';
            fileList.innerHTML = '';

            // Sort videos by season and episode
            videos.sort((a, b) => {
                const regex = /(S|s)(\d+)(E|e)(\d+)|(\d+)x(\d+)|(\d+)-(\d+)/;

                const aMatch = a.name.match(regex);
                const bMatch = b.name.match(regex);

                if (aMatch && bMatch) {
                    const aSeason = parseInt(aMatch[2] || aMatch[5] || aMatch[7], 10);
                    const aEpisode = parseInt(aMatch[4] || aMatch[6] || aMatch[8], 10);
                    const bSeason = parseInt(bMatch[2] || bMatch[5] || bMatch[7], 10);
                    const bEpisode = parseInt(bMatch[4] || bMatch[6] || bMatch[8], 10);

                    if (aSeason !== bSeason) {
                        return aSeason - bSeason;
                    }
                    return aEpisode - bEpisode;
                }
                // If no match, sort alphabetically
                return a.name.localeCompare(b.name);
            });

            videos.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <p class="file-name">${file.name}</p>
                    <p class="file-size">(${(file.size / 1024 / 1024).toFixed(2)} MB)</p>
                `;

                let hoverTimer;
                item.addEventListener('mouseenter', () => {
                    hoverTimer = setTimeout(() => {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'file-name-tooltip';
                        tooltip.textContent = file.name;
                        item.appendChild(tooltip);
                    }, 3000);
                });

                item.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimer);
                    const tooltip = item.querySelector('.file-name-tooltip');
                    if (tooltip) {
                        tooltip.remove();
                    }
                });

                item.addEventListener('click', async () => {
                    currentStreamUrl = `${API_BASE_URL}/stream-file?hash=${currentTorrentData.infoHash}&file=${file.index}`;
                    currentSelectedVideoName = baseName(file.name);
                    playerTitle.textContent = currentSelectedVideoName;
                    // Compute resume key and prefetch resume info for WebTorrent
                    try {
                        resumeKey = `webtorrent:${currentTorrentData.infoHash}:${file.index}`;
                        resumeInfo = await fetchResume(resumeKey);
                    } catch(_) {}
                    mpvControls.style.display = 'flex';
                    // Ask backend to begin downloading the selected file and subtitles, but don't start playback yet
                    try {
                        await fetch(`${API_BASE_URL}/prepare-file?hash=${currentTorrentData.infoHash}&file=${file.index}`);
                    } catch (_) {}
                    showNotification(`Selected: ${currentSelectedVideoName}. Click Play Now or Open in MPV to start.`);
                });
                fileList.appendChild(item);
            });

            if (subtitles.length > 0) {
                subtitleControls.style.display = 'flex';
                subtitleList.innerHTML = '';
                subtitleList.classList.add('subtitle-list');
                currentSubtitles = subtitles;
                subtitles.forEach(sub => {
                    const subItem = document.createElement('div');
                    subItem.className = 'subtitle-item';
                    
                    const langDiv = document.createElement('div');
                    langDiv.className = 'subtitle-lang';
                    langDiv.textContent = sub.name;
                    subItem.appendChild(langDiv);

                    subItem.addEventListener('click', async () => {
                        document.querySelectorAll('.subtitle-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        subItem.classList.add('selected');

                        currentSubtitleUrl = `${API_BASE_URL}/subtitle-file?hash=${currentTorrentData.infoHash}&file=${sub.index}`;
                        showNotification(`Selected subtitle: ${sub.name}`);
                    });
                    subtitleList.appendChild(subItem);
                });
            }
        }

        // Show the MPV player
        function showPlayer() {
            mpvPlayerContainer.classList.add('active');
        }

        // Close the MPV player
        async function closePlayer() {
            mpvPlayerContainer.classList.remove('active');
            if (currentTorrentData) {
                try {
                    await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`);
                } catch (e) {}
                if (window.electronAPI) {
                    try {
                        const result = await window.electronAPI.clearWebtorrentTemp();
                        if (result.success) {
                            showNotification('Player closed and temp files cleared.');
                        } else {
                            showNotification(`Error clearing temp files: ${result.message}`);
                        }
                    } catch (e) {}
                }
            }
            // Cleanup RD auto-downloaded subtitle if present
            try { if (currentSubtitleFile) await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
        }

        // Open stream in MPV
        async function openInMPV() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            if (!window.electronAPI || !window.electronAPI.openInMPV) {
                showNotification('MPV integration not available in this environment');
                return;
            }
            const data = {
                streamUrl: currentStreamUrl,
                infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
            };
            const result = await window.electronAPI.openInMPV(data);
            if (result.success) {
                showNotification('MPV launched Please Wait Watch out for a new tab!');
            } else {
                showNotification(`Error: ${result.message}`);
            }
        }

        // Copy stream URL to clipboard
        function copyStreamUrl() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            navigator.clipboard.writeText(currentStreamUrl).then(() => {
                showNotification('Stream URL copied to clipboard');
            });
        }

        // Download subtitles
        function downloadSubtitles() {
            if (!currentSubtitleUrl) {
                showNotification('No subtitle selected');
                return;
            }
            window.open(currentSubtitleUrl);
        }

        // Copy magnet link to clipboard
        function copyMagnet(magnet) {
            navigator.clipboard.writeText(magnet).then(() => {
                showNotification('Magnet link copied to clipboard');
            });
        }

        // Show notification with optional duration
        function showNotification(message, type = 'info', duration = 3000) {
            notification.textContent = message;
            notification.classList.add('show');
            
            // Clear any existing timeout
            if (window.notificationTimeout) {
                clearTimeout(window.notificationTimeout);
            }
            
            window.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        // Persistent update notification that stays until user restarts
        let persistentUpdateNotification = null;
        
        function showPersistentUpdateNotification() {
            // Remove any existing persistent notification
            hideUpdateNotification();
            
            // Create persistent notification element
            persistentUpdateNotification = document.createElement('div');
            persistentUpdateNotification.id = 'persistentUpdateNotification';
            persistentUpdateNotification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(34, 197, 94, 0.3);
                    z-index: 10000;
                    font-weight: 600;
                    font-size: 14px;
                    max-width: 320px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    animation: slideInRight 0.4s ease-out;
                ">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <i class="fas fa-rocket" style="font-size: 18px; color: #dcfce7;"></i>
                        <div>
                            <div style="font-size: 15px; margin-bottom: 4px;">🎉 Update Ready!</div>
                            <div style="font-size: 13px; opacity: 0.9;">Restart the app to complete the update</div>
                        </div>
                        <button onclick="restartForUpdate()" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: 1px solid rgba(255, 255, 255, 0.3);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                            Restart
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(persistentUpdateNotification);
            
            // Also show a regular notification
            showNotification('🎉 Update ready! Restart to complete installation.', 'success', 6000);
        }
        
        function hideUpdateNotification() {
            if (persistentUpdateNotification) {
                persistentUpdateNotification.remove();
                persistentUpdateNotification = null;
            }
        }
        
        function restartForUpdate() {
            hideUpdateNotification();
            // Trigger restart via the existing restart button in the overlay
            document.getElementById('updateRestartBtn')?.click();
        }

        // --- Custom Player Logic ---

        function openCustomPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            customPlayerContainer.classList.add('active');
            
            // Check if this is an HLS stream (.m3u8) and use HLS.js if needed
            if (currentStreamUrl.includes('.m3u8') && typeof Hls !== 'undefined' && Hls.isSupported()) {
                // Destroy existing HLS instance if any
                if (window.hls) {
                    window.hls.destroy();
                }
                
                // Create new HLS instance
                window.hls = new Hls({
                    enableWorker: false,
                    lowLatencyMode: false,
                    backBufferLength: 90
                });
                
                window.hls.loadSource(currentStreamUrl);
                window.hls.attachMedia(customVideo);
                
                window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('[HLS] Manifest parsed, ready to play');
                });
                
                window.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('[HLS] Error:', data);
                    if (data.fatal) {
                        if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                            console.log('[HLS] Network error, trying to recover...');
                            window.hls.startLoad();
                        } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                            console.log('[HLS] Media error, trying to recover...');
                            window.hls.recoverMediaError();
                        }
                    }
                });
            } else {
                // Ensure any previous HLS instance is destroyed
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }
                
                if (customVideo.canPlayType('application/vnd.apple.mpegurl') && currentStreamUrl.includes('.m3u8')) {
                    // Native HLS support (Safari)
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                } else {
                    // Regular video file
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                }
            }
            
            customPlayerTitle.textContent = playerTitle.textContent;
            // If resume is available, seek after metadata loaded
            if (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) {
                const to = Math.floor(resumeInfo.position);
                customVideo.addEventListener('loadedmetadata', () => { try { customVideo.currentTime = Math.min(to, (customVideo.duration || to + 1) - 1); } catch(_) {} }, { once: true });
                showNotification(`Resuming from ${formatTime(to)}`);
            }
            // Always start recording progress as soon as playback produces timeupdates
            try {
                const onFirst = () => { try { saveResumeThrottled(true); } catch(_) {} customVideo.removeEventListener('timeupdate', onFirst); };
                customVideo.addEventListener('timeupdate', onFirst);
            } catch(_) {}
            // If we prefetched a RD subtitle, attach it now
            if (currentSubtitleUrl) {
                try { loadSubtitle(currentSubtitleUrl, { label: 'Auto', lang: 'en' }); } catch(_) {}
            }

            // Reset subtitles
            if (subtitleTrack) {
                subtitleTrack.mode = 'hidden';
            }
            subtitleDisplay.style.display = 'none';
            htmlSubsPanel.style.display = 'none';
            try {
                customVideo.muted = false;
                const vol = Number(htmlVolume?.value || 80);
                customVideo.volume = Math.max(0, Math.min(1, vol / 100));
                htmlMuteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            } catch(_) {}

            // Show controls initially
            videoContainer.classList.add('show-controls');
            resetControlsAutoHide();

            // If streaming via RD proxy, add a one-time retry to re-unrestrict on error
            try {
                const u = new URL(videoSource.getAttribute('src'), window.location.origin);
                if (u.pathname.startsWith('/stream/debrid')) {
                    const origDirect = u.searchParams.get('url');
                    let retried = false;
                    customVideo.addEventListener('error', async () => {
                        if (retried) return;
                        retried = true;
                        try {
                            const base = new URL(origDirect);
                            const baseLink = `${base.origin}${base.pathname}`;
                            const rr = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: baseLink }) });
                            if (rr.ok) {
                                const rj = await rr.json();
                                if (rj?.url) {
                                    const proxied = `${API_BASE_URL}/stream/debrid?url=${encodeURIComponent(rj.url)}`;
                                    videoSource.setAttribute('src', proxied);
                                    customVideo.load();
                                    await customVideo.play();
                                }
                            }
                        } catch(_) {}
                    }, { once: false });
                }
            } catch(_) {}
        }

        // Auto-hide controls when idle in custom player
        let controlsHideTimer = null;
        const CONTROLS_HIDE_DELAY = 1500; // ms
        const videoContainer = document.getElementById('videoContainer');

        function showControls() {
            videoContainer.classList.add('show-controls');
        }

        function hideControls() {
            // Do not hide if subtitles panel is open
            if (htmlSubsPanel && htmlSubsPanel.style.display === 'block') return;
            videoContainer.classList.remove('show-controls');
        }

        function clearControlsTimer() { if (controlsHideTimer) { clearTimeout(controlsHideTimer); controlsHideTimer = null; } }

        function resetControlsAutoHide() {
            clearControlsTimer();
            showControls();
            controlsHideTimer = setTimeout(hideControls, CONTROLS_HIDE_DELAY);
        }

        // Reveal/hide on mouse activity inside video container
        videoContainer.addEventListener('mousemove', resetControlsAutoHide);
        videoContainer.addEventListener('mouseenter', resetControlsAutoHide);
        videoContainer.addEventListener('mouseleave', hideControls);
        // Keep visible while interacting with the controls bar
        videoControls.addEventListener('mouseenter', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mousemove', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mouseleave', resetControlsAutoHide);

        // When opening and closing the subtitles panel, force controls visibility appropriately
        if (htmlSubsBtn) {
            htmlSubsBtn.addEventListener('click', () => {
                // After toggling, ensure state is correct
                setTimeout(() => {
                    if (htmlSubsPanel.style.display === 'block') {
                        clearControlsTimer();
                        showControls();
                    } else {
                        resetControlsAutoHide();
                    }
                }, 0);
            });
        }
        if (htmlSubsClose) {
            htmlSubsClose.addEventListener('click', () => {
                resetControlsAutoHide();
            });
        }

        // ---- WCJS Player Logic ----
        let wcjsPlayer = null;
        let wcjsTimer = null;
        function openWCJSPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            try {
                const wc = window.electronAPI?.wcjs;
                if (!wc || !wc.available) {
                    openCustomPlayer();
                    return;
                }
                // Show container
                wcjsPlayerContainer.style.opacity = '1';
                wcjsPlayerContainer.style.pointerEvents = 'all';
                wcjsLoading.style.display = 'flex';
                wcjsPlayerTitle.textContent = playerTitle.textContent || 'WebChimera Player';

                // Init player and bind to canvas
                const ctx = wc.init('#wcjsCanvas', ["--no-video-title-show"]);
                if (!ctx || !ctx.player) {
                    showNotification('WebChimera failed to initialize, falling back to built-in player.');
                    closeWCJSPlayer();
                    openCustomPlayer();
                    return;
                }
                wcjsPlayer = ctx.player;
                // Start playback
                wcjsPlayer.play(currentStreamUrl);
                // Load pre-downloaded subtitle if available (from RD auto fetch)
                try {
                    if (currentSubtitleUrl && wcjsPlayer && wcjsPlayer.subtitles && wcjsPlayer.subtitles.load) {
                        wcjsPlayer.subtitles.load(currentSubtitleUrl);
                    }
                } catch(_) {}

                // Setup events and UI updates
                wcjsAttachEvents();
            } catch (e) {
                console.error('WCJS init error:', e);
                showNotification('WebChimera init error, using built-in player.');
                closeWCJSPlayer();
                openCustomPlayer();
            }
        }

        function wcjsAttachEvents() {
            if (!wcjsPlayer) return;
            // Length/time change handlers if available
            try { wcjsPlayer.onLengthChanged = (len) => { wcjsTotalTime.textContent = formatTime((len||0)/1000); }; } catch(_){}
            try { wcjsPlayer.onPlaying = () => { wcjsLoading.style.display = 'none'; wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'; }; } catch(_){}
            try { wcjsPlayer.onPaused = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}
            try { wcjsPlayer.onEndReached = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}

            // Poll time/length as a reliable way across versions
            clearInterval(wcjsTimer);
            wcjsTimer = setInterval(() => {
                if (!wcjsPlayer) return;
                let len = 0, t = 0;
                try { len = Number(wcjsPlayer.length || wcjsPlayer.input?.length || 0); } catch(_){}
                try { t = Number(wcjsPlayer.time || wcjsPlayer.input?.time || 0); } catch(_){}
                if (len > 0) wcjsTotalTime.textContent = formatTime(len/1000);
                wcjsCurrentTime.textContent = formatTime(t/1000);
                if (len > 0) {
                    const pct = Math.max(0, Math.min(100, (t/len) * 100));
                    wcjsProgressFilled.style.width = pct + '%';
                }
            }, 200);
            // Refresh audio list on play
            setTimeout(renderAudioTracks, 400);
        }

        async function closeWCJSPlayer() {
            wcjsPlayerContainer.style.opacity = '0';
            wcjsPlayerContainer.style.pointerEvents = 'none';
            wcjsLoading.style.display = 'none';
            clearInterval(wcjsTimer);
            wcjsTimer = null;
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            if (wcjsPlayer) {
                try { wcjsPlayer.stop(); } catch(_){}
                try { wcjsPlayer.close && wcjsPlayer.close(); } catch(_){}
            }
            wcjsPlayer = null;
            // Stop torrent stream on server and clean temp (same as MPV close)
            if (currentTorrentData) {
                try { await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`); } catch(e) {}
                if (window.electronAPI) {
                    try { await window.electronAPI.clearWebtorrentTemp(); } catch(e) {}
                }
            }
            // Cleanup downloaded temporary subtitles
            try { await fetch(`${API_BASE_URL}/subtitles/cleanup`, { method: 'POST' }); } catch(e) {}
        }

        function wcjsTogglePlayPause() {
            if (!wcjsPlayer) return;
            try { wcjsPlayer.togglePause(); } catch(_){}
        }

        function wcjsSkipTime(seconds) {
            if (!wcjsPlayer) return;
            try {
                const cur = Number(wcjsPlayer.time || 0);
                wcjsPlayer.time = Math.max(0, cur + seconds * 1000);
            } catch(_){}
        }

        function wcjsToggleFullscreen() {
            if (!document.fullscreenElement) {
                wcjsPlayerContainer.requestFullscreen?.();
            } else {
                document.exitFullscreen?.();
            }
        }

        function wcjsSeek(e) {
            if (!wcjsPlayer) return;
            const rect = wcjsProgressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const pct = offsetX / rect.width;
            try {
                const len = Number(wcjsPlayer.length || 0);
                if (len > 0) wcjsPlayer.time = Math.floor(len * pct);
            } catch(_){}
        }

        function wcjsToggleMute() {
            if (!wcjsPlayer) return;
            try {
                if (typeof wcjsPlayer.toggleMute === 'function') wcjsPlayer.toggleMute();
                else wcjsPlayer.mute = !wcjsPlayer.mute;
                // Update icon
                const muted = !!wcjsPlayer.mute;
                wcjsMuteBtn.innerHTML = muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
            } catch(_){}
        }

        function wcjsSetVolume() {
            if (!wcjsPlayer) return;
            // wcjs volume is 0..200
            const v = Number(wcjsVolume.value || 0);
            try { wcjsPlayer.volume = Math.round(v * 2); } catch(_){}
        }

        async function wcjsHandleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file || !wcjsPlayer) return;
            try {
                const text = await file.text();
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (data?.url) {
                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(data.url); } catch(_){}
                    showNotification('Subtitles loaded');
                }
            } catch (e) {
                showNotification('Failed to load subtitles');
            }
        }

        // Fetch and display subtitles from backend
        async function fetchAndRenderSubtitles() {
            wcjsSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i> Loading...</div>';
            try {
                // Always prefer the selected show's TMDB id and media type
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // Provide show title/year for better matching
                    const showTitle = currentContent?.title || currentContent?.name || '';
                    const showYear = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                    if (showTitle) params.set('title', showTitle);
                    if (showYear) params.set('year', showYear);
                } else if (type === 'tv' && currentSeason) {
                    params.set('season', String(currentSeason));
                }
                // Try to detect selected episode from episodesGrid selection
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                const items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Group by language and index duplicates
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                wcjsSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) wcjsSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                // Download via backend to temp, then load into WCJS
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(dlJson.url); } catch(_){}
                                    showNotification(`Loaded: ${displayName}`);
                                    wcjsSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        // Try fallback to Wyzie: prefer same language, else any Wyzie
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(wyJson.url); } catch(_){}
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    wcjsSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        wcjsSubsList.appendChild(row);
                    });
                }
            } catch {
                wcjsSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // Render audio tracks and allow switching
        function renderAudioTracks() {
            wcjsAudioList.innerHTML = '';
            if (!wcjsPlayer || !wcjsPlayer.audio) {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio track info not available.</div>';
                return;
            }
            try {
                const count = Number(wcjsPlayer.audio.count || 0);
                if (!count) {
                    wcjsAudioList.innerHTML = '<div class="subs-help">No alternate audio tracks.</div>';
                    return;
                }
                for (let i = 1; i <= count; i++) {
                    const name = wcjsPlayer.audio[i] || `Track ${i}`;
                    const row = document.createElement('div');
                    row.className = 'subs-item';
                    row.innerHTML = `<div>${name}</div><div class="subs-badge">Select</div>`;
                    row.addEventListener('click', () => {
                        try { wcjsPlayer.audio.track = i; showNotification(`Audio: ${name}`); wcjsAudioPanel.style.display = 'none'; } catch(_){}
                    });
                    wcjsAudioList.appendChild(row);
                }
            } catch {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio list unavailable.</div>';
            }
        }

        async function closeCustomPlayer_() {
            customPlayerContainer.classList.remove('active');
            try { customVideo.pause(); } catch(_) {}
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            // Cleanup HLS instance if any
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }
            
            // Fully reset video source to clear any residual tracks/cues
            try {
                customVideo.removeAttribute('src');
                if (videoSource) videoSource.setAttribute('src', '');
                customVideo.load();
            } catch(_) {}
            
            // Cleanup temp subtitle file for HTML5 if any
            if (currentSubtitleFile) {
                try { await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
                currentSubtitleFile = null;
            }
        }

        function togglePlayPause() {
            if (customVideo.paused) {
                // Also ensure any textTracks are disabled
                try {
                    for (const t of customVideo.textTracks || []) { t.mode = 'disabled'; }
                } catch(_){ }
                customVideo.play();
            } else {
                customVideo.pause();
            }
        }

        function skipTime(amount) {
            customVideo.currentTime += amount;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                customPlayerContainer.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function updateProgress() {
            const percent = (customVideo.currentTime / customVideo.duration) * 100;
            progressFilled.style.width = `${percent}%`;
            currentTime.textContent = formatTime(customVideo.currentTime);
            saveResumeThrottled();
        }

        function updateDuration() {
            totalTime.textContent = formatTime(customVideo.duration);
            saveResumeThrottled();
        }

        function seekVideo(e) {
            const rect = progressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const seekTime = (offsetX / progressBar.offsetWidth) * customVideo.duration;
            customVideo.currentTime = seekTime;
            saveResumeThrottled(true);
        }

        function formatTime(seconds) {
            if (!isFinite(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${String(secs).padStart(2, '0')}`;
        }

        function handleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                // Upload to server to get a URL
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                loadSubtitle(data.url);
            };
            reader.readAsText(file);
        }

        function updateSubtitleControlDisplays() {
            if (subsSizeValue) subsSizeValue.textContent = `${subtitleSettings.size}px`;
            if (subsOpacityValue) subsOpacityValue.textContent = `${subtitleSettings.backgroundOpacity}%`;
            if (subsSizeInput) subsSizeInput.value = subtitleSettings.size;
            if (subsColorInput) subsColorInput.value = subtitleSettings.color;
            if (subsBackgroundInput) subsBackgroundInput.value = subtitleSettings.background;
            if (subsBackgroundOpacityInput) subsBackgroundOpacityInput.value = subtitleSettings.backgroundOpacity;
            if (subsFontSelect) subsFontSelect.value = subtitleSettings.font;
        }

        function applySubtitleSettings() {
            // Apply styles to Video.js subtitle display
            let styleEl = document.getElementById('subtitle-cue-style');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'subtitle-cue-style';
                document.head.appendChild(styleEl);
            }
            
            // Convert hex color to rgba for background
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };
            
            const bgColor = hexToRgba(subtitleSettings.background, subtitleSettings.backgroundOpacity / 100);
            
            // Apply to Video.js text track display and native cues with fixed position
            styleEl.textContent = `
                .video-js .vjs-text-track-display {
                    bottom: 3em !important;
                    pointer-events: none !important;
                }
                
                .video-js .vjs-text-track-cue > div {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                    padding: 0.2em 0.5em !important;
                    border-radius: 4px !important;
                    pointer-events: auto !important;
                }
                
                video::cue {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                }
            `;
        }

        async function loadSubtitle(url, opts = {}) {
            // Remove existing subtitle tracks
            const existingTracks = Array.from(customVideo.querySelectorAll('track[kind="subtitles"]'));
            existingTracks.forEach(t => t.remove());
            subtitleTrack = null;

            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.label = opts.label || 'Subtitles';
            track.srclang = (opts.lang || 'en');
            track.src = url;
            track.default = true;
            track.setAttribute('default', '');
            customVideo.appendChild(track);
            // Wait for track to load then enable showing
            track.addEventListener('load', () => {
                try {
                    // Hide all other tracks then show current
                    for (const t of customVideo.textTracks) { t.mode = 'hidden'; }
                    if (track.track) track.track.mode = 'showing';
                    applySubtitleSettings();
                } catch {}
            });
            subtitleTrack = track;
            // Track the served filename so we can delete it when switching
            try {
                const u = new URL(url, window.location.origin);
                const parts = u.pathname.split('/');
                const fname = parts[parts.length - 1];
                currentSubtitleFile = decodeURIComponent(fname);
            } catch {}
        }

        async function fetchAndRenderHtmlSubs() {
            htmlSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i> Loading...</div>';
            try {
                // Always use the selected show's TMDB id and type from UI
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                const title = currentContent?.title || currentContent?.name || '';
                const year = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (title) params.set('title', title);
                if (year) params.set('year', year);
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // title/year already represent the selected show
                }
                if (type === 'tv' && currentSeason) params.set('season', String(currentSeason));
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                let items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Extra safety: filter client-side for supported formats only
                items = items.filter(it => {
                    const ext = (it.ext || it.format || '').toString().toLowerCase();
                    const u = (it.url || '').toString().toLowerCase();
                    return ['srt','vtt'].includes(ext) || u.includes('.srt') || u.includes('.vtt') || u.includes('.srt.gz') || it.file_id; // OS entries will be converted server-side
                });
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                htmlSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) htmlSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    // Delete old subtitle temp file (if any)
                                    if (currentSubtitleFile) {
                                        try {
                                            await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                        } catch {}
                                    }
                                    const langCode = (sub.lang || '').toLowerCase();
                                    await loadSubtitle(dlJson.url, { label: displayName, lang: langCode });
                                    showNotification(`Loaded: ${displayName}`);
                                    htmlSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                // Delete old subtitle temp file (if any)
                                                if (currentSubtitleFile) {
                                                    try {
                                                        await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                                    } catch {}
                                                }
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    const langCode = (wyziePick.lang || '').toLowerCase();
                                                    await loadSubtitle(wyJson.url, { label: wyziePick.name || wyziePick.langName, lang: langCode });
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    htmlSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        htmlSubsList.appendChild(row);
                    });
                }
            } catch {
                htmlSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // Initialize the app on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', init);

        // ---- Resume helpers ----
        async function fetchResume(key) {
            if (!key) return null;
            try {
                const r = await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(key)}`);
                if (!r.ok) return null;
                const j = await r.json();
                if (j && typeof j.position === 'number' && j.position > 0) return j;
            } catch(_){ }
            return null;
        }
        async function saveResume() {
            if (!resumeKey || !customVideo || !isFinite(customVideo.duration) || !isFinite(customVideo.currentTime)) return;
            const pos = Math.max(0, Math.floor(customVideo.currentTime || 0));
            const dur = Math.max(0, Math.floor(customVideo.duration || 0));
            const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
            if (dur === 0 || pos === 0) return;
            try {
                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: pos, duration: dur, title }) });
            } catch(_){ }
        }
        function saveResumeThrottled(immediate = false) {
            const now = Date.now();
            if (immediate || now - lastResumeSend > 2500) {
                lastResumeSend = now;
                clearTimeout(resumeTimer);
                resumeTimer = null;
                saveResume();
                return;
            }
            if (!resumeTimer) {
                resumeTimer = setTimeout(() => { lastResumeSend = Date.now(); saveResume(); resumeTimer = null; }, 1500);
            }
        }
        try {
            customVideo.addEventListener('ended', async () => {
                if (resumeKey) {
                    try { await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                }
            });
        } catch(_){ }

        // ---- Updater overlay wiring (non-intrusive) ----
        try {
            const overlay = document.getElementById('updateOverlay');
            const icon = document.getElementById('updateStatusIcon');
            const text = document.getElementById('updateStatusText');
            const bar = document.getElementById('updateProgressBar');
            const pct = document.getElementById('updatePercent');
            const restartBtn = document.getElementById('updateRestartBtn');

            function showOverlay() {
                if (overlay) overlay.style.display = 'flex';
                document.body && (document.body.style.overflow = 'hidden');
            }
            function hideOverlay() {
                if (overlay) overlay.style.display = 'none';
                document.body && (document.body.style.overflow = 'auto');
            }

            if (window.electronAPI) {
                // When update check starts, show longer notification
                window.electronAPI.onUpdateChecking?.((_info) => {
                    showNotification('🔍 Checking for updates...', 'info', 5000); // Show for 5 seconds
                });

                // When no update is available, show longer notification
                window.electronAPI.onUpdateNotAvailable?.((_info) => {
                    showNotification('✅ App is up to date', 'success', 4000); // Show for 4 seconds
                });
                
                // When update becomes available, show persistent overlay and notification
                window.electronAPI.onUpdateAvailable?.((_info) => {
                    showOverlay();
                    if (icon) { icon.className = 'fas fa-download'; icon.style.animation = 'pulse 1.5s ease-in-out infinite'; icon.style.color = '#a855f7'; }
                    if (text) text.textContent = 'Update found! Download starting, please wait...';
                    if (bar) bar.style.width = '0%';
                    if (pct) pct.textContent = '0%';
                    if (restartBtn) restartBtn.style.display = 'none';
                    
                    const warningText = document.getElementById('updateWarningText');
                    if (warningText) warningText.textContent = '⚠️ Downloading update - please keep the app open';
                    
                    // Show persistent notification that update download started
                    showNotification('📥 Update found! Download starting...', 'info', 8000); // Show for 8 seconds
                });
                
                // Progress updates - keep overlay visible throughout download
                window.electronAPI.onUpdateProgress?.((p) => {
                    const percent = Math.max(0, Math.min(100, Math.round(p?.percent || 0)));
                    if (bar) bar.style.width = percent + '%';
                    if (pct) pct.textContent = percent + '%';
                    if (text) text.textContent = `Downloading update... ${percent}% complete`;
                    if (icon) { icon.className = 'fas fa-download'; icon.style.animation = 'pulse 1.5s ease-in-out infinite'; }
                    
                    // Show progress notification every 25%
                    if (percent > 0 && percent % 25 === 0) {
                        showNotification(`📥 Download progress: ${percent}%`, 'info', 3000);
                    }
                });
                
                // Download finished - keep overlay visible and show persistent restart notification
                window.electronAPI.onUpdateDownloaded?.((_info) => {
                    if (icon) { icon.className = 'fas fa-check-circle'; icon.style.animation = 'none'; icon.style.color = '#22c55e'; }
                    if (text) text.textContent = 'Update downloaded successfully! Click "Restart Now" to complete the update.';
                    if (bar) bar.style.width = '100%';
                    if (pct) pct.textContent = '100%';
                    if (restartBtn) restartBtn.style.display = 'inline-flex';
                    
                    const warningText = document.getElementById('updateWarningText');
                    if (warningText) warningText.textContent = '✅ Update ready! You can restart the app anytime to apply the update';
                    
                    const closeBtn = document.getElementById('updateCloseBtn');
                    if (closeBtn) closeBtn.style.display = 'flex';
                    
                    // Show persistent restart notification that stays until user restarts
                    showPersistentUpdateNotification();
                    
                    // Auto-dismiss overlay after 10 seconds, but keep persistent notification
                    setTimeout(() => {
                        hideOverlay();
                    }, 10000);
                });
                
                // Restart button
                restartBtn?.addEventListener('click', async () => {
                    try { 
                        hideUpdateNotification(); // Hide the persistent notification
                        await window.electronAPI.installUpdateNow?.(); 
                    } catch(_) {}
                });
            }
        } catch(_){ }

        // ---- My List functionality ----
        let myListCache = [];

        async function loadMyList() {
            try {
                const response = await window.electronAPI.myListRead();
                if (response.success) {
                    myListCache = response.data || [];
                    return myListCache;
                } else {
                    console.error('Failed to load my list:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading my list:', error);
                return [];
            }
        }

        async function saveMyList() {
            try {
                const response = await window.electronAPI.myListWrite(myListCache);
                if (!response.success) {
                    console.error('Failed to save my list:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving my list:', error);
                return false;
            }
        }

        async function toggleMyList(event, id, mediaType, title, posterPath, year, rating) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.add-to-list-btn');
            if (!button) return;

            const existingIndex = myListCache.findIndex(item => item.id === id && item.media_type === mediaType);
            
            if (existingIndex >= 0) {
                // Remove from list
                myListCache.splice(existingIndex, 1);
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
            } else {
                // Add to list
                const listItem = {
                    id: id,
                    media_type: mediaType,
                    title: title,
                    poster_path: posterPath,
                    year: year,
                    vote_average: rating,
                    added_date: new Date().toISOString()
                };
                myListCache.unshift(listItem); // Add to beginning
                button.classList.add('in-list');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Remove from My List';
            }

            await saveMyList();
            
            // Refresh My List page if it's currently open
            if (document.getElementById('myListPage').style.display !== 'none') {
                displayMyList();
            }
        }

        function updateCardListStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.add-to-list-btn');
            if (!button) return;

            const isInList = myListCache.some(item => item.id === id && item.media_type === mediaType);
            
            if (isInList) {
                button.classList.add('in-list');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Remove from My List';
            } else {
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            const isDone = doneWatchingCache.some(item => item.id === id && item.media_type === mediaType);
            
            if (isDone) {
                button.classList.add('watched');
                button.innerHTML = '<i class="fas fa-check-double"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('watched');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Add to Done Watching';
            }
        }

        async function displayMyList() {
            const grid = document.getElementById('myListGrid');
            const loading = document.getElementById('myListLoading');
            const empty = document.getElementById('myListEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadMyList();

            loading.style.display = 'none';

            if (myListCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            myListCache.forEach(item => {
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = item.vote_average || 0;
                card.dataset.date = `${item.year}-01-01`; // Approximate date for consistency
                card.innerHTML = `
                    <button class="add-to-list-btn in-list" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                        <i class="fas fa-check"></i>
                    </button>
                    <img src="https://image.tmdb.org/t/p/w500${item.poster_path}" alt="${item.title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title}</h3>
                        <p class="movie-year">${item.year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearMyList() {
            if (confirm('Are you sure you want to clear your entire list? This action cannot be undone.')) {
                myListCache = [];
                await saveMyList();
                
                // Update all visible cards
                document.querySelectorAll('.add-to-list-btn.in-list').forEach(button => {
                    button.classList.remove('in-list');
                    button.innerHTML = '<i class="fas fa-plus"></i>';
                    button.title = 'Add to My List';
                });
                
                // Refresh My List page if open
                if (document.getElementById('myListPage').style.display !== 'none') {
                    displayMyList();
                }
            }
        }

        // ---- Done Watching functionality ----
        let doneWatchingCache = [];

        async function loadDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingRead();
                if (response.success) {
                    doneWatchingCache = response.data || [];
                    return doneWatchingCache;
                } else {
                    console.error('Failed to load done watching:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading done watching:', error);
                return [];
            }
        }

        async function saveDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingWrite(doneWatchingCache);
                if (!response.success) {
                    console.error('Failed to save done watching:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving done watching:', error);
                return false;
            }
        }

        async function toggleDoneWatching(event, id, mediaType, title, posterPath, year, rating) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.done-watching-btn');
            if (!button) return;

            const existingIndex = doneWatchingCache.findIndex(item => item.id === id && item.media_type === mediaType);
            
            if (existingIndex >= 0) {
                // Remove from done watching
                doneWatchingCache.splice(existingIndex, 1);
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            } else {
                // Add to done watching
                const doneItem = {
                    id: id,
                    media_type: mediaType,
                    title: title,
                    poster_path: posterPath,
                    year: year,
                    vote_average: rating,
                    completed_date: new Date().toISOString()
                };
                doneWatchingCache.unshift(doneItem); // Add to beginning
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            }

            await saveDoneWatching();
            
            // Refresh Done Watching page if it's currently open
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            const isDone = doneWatchingCache.some(item => item.id === id && item.media_type === mediaType);
            
            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayDoneWatching() {
            const grid = document.getElementById('doneWatchingGrid');
            const loading = document.getElementById('doneWatchingLoading');
            const empty = document.getElementById('doneWatchingEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadDoneWatching();

            loading.style.display = 'none';

            if (doneWatchingCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            doneWatchingCache.forEach(item => {
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = item.vote_average || 0;
                card.dataset.date = `${item.year}-01-01`; // Approximate date for consistency
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button class="done-watching-btn is-done" onclick="toggleDoneWatching(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                        <i class="fas fa-check-circle"></i>
                    </button>
                    <img src="https://image.tmdb.org/t/p/w500${item.poster_path}" alt="${item.title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title}</h3>
                        <p class="movie-year">${item.year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn') && !e.target.closest('.done-watching-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearDoneWatching() {
            if (confirm('Are you sure you want to clear your entire done watching list? This action cannot be undone.')) {
                doneWatchingCache = [];
                await saveDoneWatching();
                
                // Update all visible cards
                document.querySelectorAll('.done-watching-btn.is-done').forEach(button => {
                    button.classList.remove('is-done');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.title = 'Mark as Done Watching';
                });
                
                // Refresh Done Watching page if open
                if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                    displayDoneWatching();
                }
            }
        }

        // Load both lists on app start
        document.addEventListener('DOMContentLoaded', async () => {
            await loadMyList();
            await loadDoneWatching();
            
            // Update existing cards with both list statuses when movies are loaded
            const originalDisplayMovies = displayMovies;
            displayMovies = function(movies, append = true) {
                const result = originalDisplayMovies.call(this, movies, append);
                
                // Update both list and done watching status for newly added cards
                setTimeout(() => {
                    movies.forEach(movie => {
                        const cards = document.querySelectorAll(`[data-rating="${movie.vote_average || 0}"]`);
                        cards.forEach(card => {
                            updateCardListStatus(card, movie.id, movie.media_type || 'movie');
                            updateCardDoneStatus(card, movie.id, movie.media_type || 'movie');
                        });
                    });
                }, 100);
                
                return result;
            };

            // Also update cards for genre items
            const originalDisplayGenreItems = displayGenreItems;
            displayGenreItems = function(items, mediaType) {
                const result = originalDisplayGenreItems.call(this, items, mediaType);
                
                // Update both list and done watching status for genre cards
                setTimeout(() => {
                    items.forEach(item => {
                        const cards = document.querySelectorAll(`.movie-card`);
                        cards.forEach(card => {
                            const cardImg = card.querySelector('img');
                            if (cardImg && cardImg.src.includes(item.poster_path)) {
                                updateCardListStatus(card, item.id, mediaType);
                                updateCardDoneStatus(card, item.id, mediaType);
                            }
                        });
                    });
                }, 100);
                
                return result;
            };

            // Add button handlers
            document.getElementById('clearMyListBtn')?.addEventListener('click', clearMyList);
            document.getElementById('clearDoneWatchingBtn')?.addEventListener('click', clearDoneWatching);
        });
    </script>
    
    <!-- Updater Overlay (enhanced, user-friendly) -->
    <div id="updateOverlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999; display:none; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
        <div style="background:linear-gradient(135deg, #2a1847 0%, #1f1235 100%); border:2px solid #a855f7; padding:2.5rem; border-radius:16px; width:min(90%, 480px); text-align:center; color:#f8f9fa; box-shadow:0 20px 40px rgba(0,0,0,0.5); position:relative;">
            <!-- Close button (only shown when download is complete) -->
            <button id="updateCloseBtn" onclick="hideOverlay()" style="position:absolute; top:15px; right:15px; background:rgba(255,255,255,0.1); border:none; color:#c084fc; width:32px; height:32px; border-radius:50%; cursor:pointer; display:none; align-items:center; justify-content:center; transition:all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                <i class="fas fa-times" style="font-size:14px;"></i>
            </button>
            
            <div id="updateStatusIcon" class="fas fa-download" style="font-size:3rem; margin-bottom:1.5rem; color:#a855f7; animation: spin 1s linear infinite;"></div>
            <h2 style="margin:0 0 0.5rem 0; font-size:1.5rem; font-weight:600;">App Update in Progress</h2>
            <p id="updateStatusText" style="margin:0.25rem 0 1.5rem 0; color:#c084fc; font-size:1rem; line-height:1.4;">Update found! Downloading now, please wait...</p>
            <div style="height:12px; background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden; margin-bottom:12px; box-shadow:inset 0 2px 4px rgba(0,0,0,0.3);">
                <div id="updateProgressBar" style="height:100%; width:0%; background:linear-gradient(90deg, #a855f7, #22c55e); transition:width 0.4s ease; border-radius:12px;"></div>
            </div>
            <div id="updatePercent" style="font-weight:700; color:#a855f7; font-size:1.1rem; margin-bottom:1rem;">0%</div>
            <p id="updateWarningText" style="margin:0.5rem 0 1rem 0; color:#8b5cf6; font-size:0.9rem; opacity:0.8;">⚠️ Please do not close the application during the update</p>
            <button id="updateRestartBtn" class="btn btn-primary" style="margin-top:1rem; display:none; padding:0.75rem 2rem; font-size:1rem; border-radius:8px;">
                <i class="fas fa-sync-alt"></i> Restart Now to Complete Update
            </button>
        </div>
    </div>

    <!-- Resume Prompt Modal (top-level) -->
    <div class="modal" id="resumeModal">
        <div class="modal-content" style="max-width:480px">
            <button class="modal-close" id="resumeClose"><i class="fas fa-times"></i></button>
            <div class="modal-header">
                <div class="modal-header-content" style="gap:0.75rem; align-items:center;">
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <i class="fas fa-history" style="color: var(--vlc-orange);"></i>
                        <h2 class="modal-title" id="resumeTitle" style="margin:0; font-size:1.3rem;">Resume playback?</h2>
                    </div>
                    <div class="modal-info" style="display:flex; gap:0.5rem; align-items:center;">
                        <span id="resumeTime" class="genre-chip">00:00</span>
                    </div>
                </div>
            </div>
            <div class="modal-body" style="padding-top:0.5rem;">
                <p class="modal-overview" id="resumeText" style="margin-bottom:1rem;">You have previous progress for this title. Would you like to continue from where you left off?</p>
                <div style="display:flex; gap:0.75rem; justify-content:flex-end;">
                    <button class="btn btn-outline" id="resumeStartOver"><i class="fas fa-undo"></i> Start Over</button>
                    <button class="btn" id="resumeContinue"><i class="fas fa-play"></i> Continue</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
